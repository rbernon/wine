/*
 * Win32 5.1 msstyles theme format
 *
 * Copyright (C) 2004 Kevin Koltzau
 * Copyright 2021-2022 Zhiyi Zhang for CodeWeavers
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
 */

#include <stdarg.h>
#include <stdlib.h>

#include "windef.h"
#include "winbase.h"
#include "wingdi.h"
#include "winuser.h"
#include "winnls.h"
#include "vfwmsgs.h"
#include "uxtheme.h"
#include "vssym32.h"

#include "msstyles.h"

#include "wine/exception.h"
#include "wine/debug.h"
#include "wine/heap.h"
#include "wine/rbtree.h"

WINE_DEFAULT_DEBUG_CHANNEL(uxtheme);

/***********************************************************************
 * Defines and global variables
 */

static BOOL MSSTYLES_ParseIniSectionName(LPCWSTR lpSection, DWORD dwLen, LPWSTR szAppName, LPWSTR szClassName, int *iPartId, int *iStateId);
static BOOL MSSTYLES_GetNextInteger(LPCWSTR lpStringStart, LPCWSTR lpStringEnd, LPCWSTR *lpValEnd, int *value);
static BOOL MSSTYLES_GetNextLong(LPCWSTR lpStringStart, LPCWSTR lpStringEnd, LPCWSTR *lpValEnd, LONG *value);
static BOOL MSSTYLES_GetNextToken(LPCWSTR lpStringStart, LPCWSTR lpStringEnd, LPCWSTR *lpValEnd, LPWSTR lpBuff, DWORD buffSize);
static void MSSTYLES_ParseThemeIni(PTHEME_FILE tf, BOOL setMetrics);
static HRESULT MSSTYLES_GetFont (LPCWSTR lpStringStart, LPCWSTR lpStringEnd, LPCWSTR *lpValEnd, LOGFONTW* logfont);

#define TMT_ENUM 200
#define TMT_STOCKIMAGEFILE 3007

#define MSSTYLES_VERSION 0x0003

#define THEME_CLASS_SIGNATURE 0x12bc6d83

static PTHEME_FILE tfActiveTheme;

struct uxini_string
{
    const WCHAR *buf;
    SIZE_T len;
};

static inline int uxini_string_compare(const struct uxini_string *a, const struct uxini_string *b)
{
    return CompareStringOrdinal(a->buf, a->len, b->buf, b->len, TRUE) - CSTR_EQUAL;
}

struct uxini_value
{
    struct wine_rb_entry entry;
    struct uxini_string section;
    struct uxini_string name;
    struct uxini_string value;
    int part_id;
    int state_id;
    int is_global;
    int prop_type;
    int prop_id;
};

static int uxini_value_compare(const void *key, const struct wine_rb_entry *entry)
{
    struct uxini_value *value = WINE_RB_ENTRY_VALUE(entry, struct uxini_value, entry);
    const struct uxini_string *lookup = key;
    int ret;

    if ((ret = uxini_string_compare(&lookup[0], &value->section))) return ret;
    if ((ret = uxini_string_compare(&lookup[1], &value->name))) return ret;
    return 0;
}

static void uxini_value_destroy(struct wine_rb_entry *entry, void *context)
{
    struct uxini_value *value = WINE_RB_ENTRY_VALUE(entry, struct uxini_value, entry);
    heap_free(value);
}

typedef struct _UXINI_FILE
{
    LPCWSTR lpIni;
    LPCWSTR lpCurLoc;
    LPCWSTR lpEnd;
    struct wine_rb_tree sys_metrics;
    struct wine_rb_tree values;
} UXINI_FILE, *PUXINI_FILE;

struct MSSTYLES_PROPERTY_MAP
{
    WCHAR szPropertyName[24];
    WORD dwPrimitiveType;
    WORD dwPropertyID;
};

/* Keep this is sorted by name, we use bsearch to lookup properties. */
static const struct MSSTYLES_PROPERTY_MAP mapProperty[] =
{
    {L"ACCENTCOLORHINT", TMT_COLOR, TMT_ACCENTCOLORHINT},
    {L"ACTIVEBORDER", TMT_COLOR, TMT_ACTIVEBORDER},
    {L"ACTIVECAPTION", TMT_COLOR, TMT_ACTIVECAPTION},
    {L"ALPHALEVEL", TMT_INT, TMT_ALPHALEVEL},
    {L"ALPHATHRESHOLD", TMT_INT, TMT_ALPHATHRESHOLD},
    {L"ALWAYSSHOWSIZINGBAR", TMT_BOOL, TMT_ALWAYSSHOWSIZINGBAR},
    {L"APPWORKSPACE", TMT_COLOR, TMT_APPWORKSPACE},
    {L"AUTHOR", TMT_STRING, TMT_AUTHOR},
    {L"AUTOSIZE", TMT_BOOL, TMT_AUTOSIZE},
    {L"BACKGROUND", TMT_COLOR, TMT_BACKGROUND},
    {L"BGFILL", TMT_BOOL, TMT_BGFILL},
    {L"BGTYPE", TMT_ENUM, TMT_BGTYPE},
    {L"BLENDCOLOR", TMT_COLOR, TMT_BLENDCOLOR},
    {L"BODYFONT", TMT_FONT, TMT_BODYFONT},
    {L"BOOL", TMT_BOOL, TMT_BOOL},
    {L"BORDERCOLOR", TMT_COLOR, TMT_BORDERCOLOR},
    {L"BORDERCOLORHINT", TMT_COLOR, TMT_BORDERCOLORHINT},
    {L"BORDERONLY", TMT_BOOL, TMT_BORDERONLY},
    {L"BORDERSIZE", TMT_INT, TMT_BORDERSIZE},
    {L"BORDERTYPE", TMT_ENUM, TMT_BORDERTYPE},
    {L"BTNFACE", TMT_COLOR, TMT_BTNFACE},
    {L"BTNHIGHLIGHT", TMT_COLOR, TMT_BTNHIGHLIGHT},
    {L"BTNSHADOW", TMT_COLOR, TMT_BTNSHADOW},
    {L"BTNTEXT", TMT_COLOR, TMT_BTNTEXT},
    {L"BUTTONALTERNATEFACE", TMT_COLOR, TMT_BUTTONALTERNATEFACE},
    {L"CAPTIONBARHEIGHT", TMT_SIZE, TMT_CAPTIONBARHEIGHT},
    {L"CAPTIONBARWIDTH", TMT_SIZE, TMT_CAPTIONBARWIDTH},
    {L"CAPTIONFONT", TMT_FONT, TMT_CAPTIONFONT},
    {L"CAPTIONMARGINS", TMT_MARGINS, TMT_CAPTIONMARGINS},
    {L"CAPTIONTEXT", TMT_COLOR, TMT_CAPTIONTEXT},
    {L"CHARSET", TMT_INT, TMT_CHARSET},
    {L"COLOR", TMT_COLOR, TMT_COLOR},
    {L"COLORSCHEMES", TMT_STRING, TMT_COLORSCHEMES},
    {L"COMPANY", TMT_STRING, TMT_COMPANY},
    {L"COMPOSITED", TMT_BOOL, TMT_COMPOSITED},
    {L"CONTENTALIGNMENT", TMT_ENUM, TMT_CONTENTALIGNMENT},
    {L"CONTENTMARGINS", TMT_MARGINS, TMT_CONTENTMARGINS},
    {L"COPYRIGHT", TMT_STRING, TMT_COPYRIGHT},
    {L"CSSNAME", TMT_STRING, TMT_CSSNAME},
    {L"DEFAULTPANESIZE", TMT_RECT, TMT_DEFAULTPANESIZE},
    {L"DESCRIPTION", TMT_STRING, TMT_DESCRIPTION},
    {L"DISPLAYNAME", TMT_STRING, TMT_DISPLAYNAME},
    {L"DKSHADOW3D", TMT_COLOR, TMT_DKSHADOW3D},
    {L"EDGEDKSHADOWCOLOR", TMT_COLOR, TMT_EDGEDKSHADOWCOLOR},
    {L"EDGEFILLCOLOR", TMT_COLOR, TMT_EDGEFILLCOLOR},
    {L"EDGEHIGHLIGHTCOLOR", TMT_COLOR, TMT_EDGEHIGHLIGHTCOLOR},
    {L"EDGELIGHTCOLOR", TMT_COLOR, TMT_EDGELIGHTCOLOR},
    {L"EDGESHADOWCOLOR", TMT_COLOR, TMT_EDGESHADOWCOLOR},
    {L"FILENAME", TMT_FILENAME, TMT_FILENAME},
    {L"FILLCOLOR", TMT_COLOR, TMT_FILLCOLOR},
    {L"FILLCOLORHINT", TMT_COLOR, TMT_FILLCOLORHINT},
    {L"FILLTYPE", TMT_ENUM, TMT_FILLTYPE},
    {L"FLATMENUS", TMT_BOOL, TMT_FLATMENUS},
    {L"FONT", TMT_FONT, TMT_FONT},
    {L"FROMCOLOR1", TMT_COLOR, TMT_FROMCOLOR1},
    {L"FROMCOLOR2", TMT_COLOR, TMT_FROMCOLOR2},
    {L"FROMCOLOR3", TMT_COLOR, TMT_FROMCOLOR3},
    {L"FROMCOLOR4", TMT_COLOR, TMT_FROMCOLOR4},
    {L"FROMCOLOR5", TMT_COLOR, TMT_FROMCOLOR5},
    {L"FROMHUE1", TMT_INT, TMT_FROMHUE1},
    {L"FROMHUE2", TMT_INT, TMT_FROMHUE2},
    {L"FROMHUE3", TMT_INT, TMT_FROMHUE3},
    {L"FROMHUE4", TMT_INT, TMT_FROMHUE4},
    {L"FROMHUE5", TMT_INT, TMT_FROMHUE5},
    {L"GLOWCOLOR", TMT_COLOR, TMT_GLOWCOLOR},
    {L"GLYPHFONT", TMT_FONT, TMT_GLYPHFONT},
    {L"GLYPHFONTSIZINGTYPE", TMT_ENUM, TMT_GLYPHFONTSIZINGTYPE},
    {L"GLYPHIMAGEFILE", TMT_FILENAME, TMT_GLYPHIMAGEFILE},
    {L"GLYPHINDEX", TMT_INT, TMT_GLYPHINDEX},
    {L"GLYPHONLY", TMT_BOOL, TMT_GLYPHONLY},
    {L"GLYPHTEXTCOLOR", TMT_COLOR, TMT_GLYPHTEXTCOLOR},
    {L"GLYPHTRANSPARENT", TMT_BOOL, TMT_GLYPHTRANSPARENT},
    {L"GLYPHTRANSPARENTCOLOR", TMT_COLOR, TMT_GLYPHTRANSPARENTCOLOR},
    {L"GLYPHTYPE", TMT_ENUM, TMT_GLYPHTYPE},
    {L"GRADIENTACTIVECAPTION", TMT_COLOR, TMT_GRADIENTACTIVECAPTION},
    {L"GRADIENTCOLOR1", TMT_COLOR, TMT_GRADIENTCOLOR1},
    {L"GRADIENTCOLOR2", TMT_COLOR, TMT_GRADIENTCOLOR2},
    {L"GRADIENTCOLOR3", TMT_COLOR, TMT_GRADIENTCOLOR3},
    {L"GRADIENTCOLOR4", TMT_COLOR, TMT_GRADIENTCOLOR4},
    {L"GRADIENTCOLOR5", TMT_COLOR, TMT_GRADIENTCOLOR5},
    {L"GRADIENTINACTIVECAPTION", TMT_COLOR, TMT_GRADIENTINACTIVECAPTION},
    {L"GRADIENTRATIO1", TMT_INT, TMT_GRADIENTRATIO1},
    {L"GRADIENTRATIO2", TMT_INT, TMT_GRADIENTRATIO2},
    {L"GRADIENTRATIO3", TMT_INT, TMT_GRADIENTRATIO3},
    {L"GRADIENTRATIO4", TMT_INT, TMT_GRADIENTRATIO4},
    {L"GRADIENTRATIO5", TMT_INT, TMT_GRADIENTRATIO5},
    {L"GRAYTEXT", TMT_COLOR, TMT_GRAYTEXT},
    {L"HALIGN", TMT_ENUM, TMT_HALIGN},
    {L"HEADING1FONT", TMT_FONT, TMT_HEADING1FONT},
    {L"HEADING2FONT", TMT_FONT, TMT_HEADING2FONT},
    {L"HEIGHT", TMT_SIZE, TMT_HEIGHT},
    {L"HIGHLIGHT", TMT_COLOR, TMT_HIGHLIGHT},
    {L"HIGHLIGHTTEXT", TMT_COLOR, TMT_HIGHLIGHTTEXT},
    {L"HOTTRACKING", TMT_COLOR, TMT_HOTTRACKING},
    {L"ICONEFFECT", TMT_ENUM, TMT_ICONEFFECT},
    {L"ICONTITLEFONT", TMT_FONT, TMT_ICONTITLEFONT},
    {L"IMAGECOUNT", TMT_INT, TMT_IMAGECOUNT},
    {L"IMAGEFILE", TMT_FILENAME, TMT_IMAGEFILE},
    {L"IMAGEFILE1", TMT_FILENAME, TMT_IMAGEFILE1},
    {L"IMAGEFILE2", TMT_FILENAME, TMT_IMAGEFILE2},
    {L"IMAGEFILE3", TMT_FILENAME, TMT_IMAGEFILE3},
    {L"IMAGEFILE4", TMT_FILENAME, TMT_IMAGEFILE4},
    {L"IMAGEFILE5", TMT_FILENAME, TMT_IMAGEFILE5},
    {L"IMAGEFILE6", TMT_FILENAME, TMT_IMAGEFILE6},
    {L"IMAGEFILE7", TMT_FILENAME, TMT_IMAGEFILE7},
    {L"IMAGELAYOUT", TMT_ENUM, TMT_IMAGELAYOUT},
    {L"IMAGESELECTTYPE", TMT_ENUM, TMT_IMAGESELECTTYPE},
    {L"INACTIVEBORDER", TMT_COLOR, TMT_INACTIVEBORDER},
    {L"INACTIVECAPTION", TMT_COLOR, TMT_INACTIVECAPTION},
    {L"INACTIVECAPTIONTEXT", TMT_COLOR, TMT_INACTIVECAPTIONTEXT},
    {L"INFOBK", TMT_COLOR, TMT_INFOBK},
    {L"INFOTEXT", TMT_COLOR, TMT_INFOTEXT},
    {L"INT", TMT_INT, TMT_INT},
    {L"INTEGRALSIZING", TMT_BOOL, TMT_INTEGRALSIZING},
    {L"INTLIST", TMT_INTLIST, TMT_INTLIST},
    {L"LIGHT3D", TMT_COLOR, TMT_LIGHT3D},
    {L"MARGINS", TMT_MARGINS, TMT_MARGINS},
    {L"MENU", TMT_COLOR, TMT_MENU},
    {L"MENUBAR", TMT_COLOR, TMT_MENUBAR},
    {L"MENUBARHEIGHT", TMT_SIZE, TMT_MENUBARHEIGHT},
    {L"MENUBARWIDTH", TMT_SIZE, TMT_MENUBARWIDTH},
    {L"MENUFONT", TMT_FONT, TMT_MENUFONT},
    {L"MENUHILIGHT", TMT_COLOR, TMT_MENUHILIGHT},
    {L"MENUTEXT", TMT_COLOR, TMT_MENUTEXT},
    {L"MINCOLORDEPTH", TMT_INT, TMT_MINCOLORDEPTH},
    {L"MINDPI1", TMT_INT, TMT_MINDPI1},
    {L"MINDPI2", TMT_INT, TMT_MINDPI2},
    {L"MINDPI3", TMT_INT, TMT_MINDPI3},
    {L"MINDPI4", TMT_INT, TMT_MINDPI4},
    {L"MINDPI5", TMT_INT, TMT_MINDPI5},
    {L"MINDPI6", TMT_INT, TMT_MINDPI6},
    {L"MINDPI7", TMT_INT, TMT_MINDPI7},
    {L"MINSIZE", TMT_POSITION, TMT_MINSIZE},
    {L"MINSIZE1", TMT_POSITION, TMT_MINSIZE1},
    {L"MINSIZE2", TMT_POSITION, TMT_MINSIZE2},
    {L"MINSIZE3", TMT_POSITION, TMT_MINSIZE3},
    {L"MINSIZE4", TMT_POSITION, TMT_MINSIZE4},
    {L"MINSIZE5", TMT_POSITION, TMT_MINSIZE5},
    {L"MINSIZE6", TMT_POSITION, TMT_MINSIZE6},
    {L"MINSIZE7", TMT_POSITION, TMT_MINSIZE7},
    {L"MIRRORIMAGE", TMT_BOOL, TMT_MIRRORIMAGE},
    {L"MSGBOXFONT", TMT_FONT, TMT_MSGBOXFONT},
    {L"NORMALSIZE", TMT_POSITION, TMT_NORMALSIZE},
    {L"OFFSET", TMT_POSITION, TMT_OFFSET},
    {L"OFFSETTYPE", TMT_ENUM, TMT_OFFSETTYPE},
    {L"POSITION", TMT_POSITION, TMT_POSITION},
    {L"PROGRESSCHUNKSIZE", TMT_INT, TMT_PROGRESSCHUNKSIZE},
    {L"PROGRESSSPACESIZE", TMT_INT, TMT_PROGRESSSPACESIZE},
    {L"RECT", TMT_RECT, TMT_RECT},
    {L"ROUNDCORNERHEIGHT", TMT_INT, TMT_ROUNDCORNERHEIGHT},
    {L"ROUNDCORNERWIDTH", TMT_INT, TMT_ROUNDCORNERWIDTH},
    {L"SATURATION", TMT_INT, TMT_SATURATION},
    {L"SCROLLBAR", TMT_COLOR, TMT_SCROLLBAR},
    {L"SCROLLBARHEIGHT", TMT_SIZE, TMT_SCROLLBARHEIGHT},
    {L"SCROLLBARWIDTH", TMT_SIZE, TMT_SCROLLBARWIDTH},
    {L"SHADOWCOLOR", TMT_COLOR, TMT_SHADOWCOLOR},
    {L"SIZE", TMT_SIZE, TMT_SIZE},
    {L"SIZES", TMT_STRING, TMT_SIZES},
    {L"SIZINGBORDERWIDTH", TMT_SIZE, TMT_SIZINGBORDERWIDTH},
    {L"SIZINGMARGINS", TMT_MARGINS, TMT_SIZINGMARGINS},
    {L"SIZINGTYPE", TMT_ENUM, TMT_SIZINGTYPE},
    {L"SMALLCAPTIONFONT", TMT_FONT, TMT_SMALLCAPTIONFONT},
    {L"SMCAPTIONBARHEIGHT", TMT_SIZE, TMT_SMCAPTIONBARHEIGHT},
    {L"SMCAPTIONBARWIDTH", TMT_SIZE, TMT_SMCAPTIONBARWIDTH},
    {L"SOURCEGROW", TMT_BOOL, TMT_SOURCEGROW},
    {L"SOURCESHRINK", TMT_BOOL, TMT_SOURCESHRINK},
    {L"STATUSFONT", TMT_FONT, TMT_STATUSFONT},
    {L"STOCKIMAGEFILE", TMT_FILENAME, TMT_STOCKIMAGEFILE},
    {L"STRING", TMT_STRING, TMT_STRING},
    {L"TEXT", TMT_STRING, TMT_TEXT},
    {L"TEXTBORDERCOLOR", TMT_COLOR, TMT_TEXTBORDERCOLOR},
    {L"TEXTBORDERSIZE", TMT_INT, TMT_TEXTBORDERSIZE},
    {L"TEXTCOLOR", TMT_COLOR, TMT_TEXTCOLOR},
    {L"TEXTSHADOWCOLOR", TMT_COLOR, TMT_TEXTSHADOWCOLOR},
    {L"TEXTSHADOWOFFSET", TMT_POSITION, TMT_TEXTSHADOWOFFSET},
    {L"TEXTSHADOWTYPE", TMT_ENUM, TMT_TEXTSHADOWTYPE},
    {L"TOCOLOR1", TMT_COLOR, TMT_TOCOLOR1},
    {L"TOCOLOR2", TMT_COLOR, TMT_TOCOLOR2},
    {L"TOCOLOR3", TMT_COLOR, TMT_TOCOLOR3},
    {L"TOCOLOR4", TMT_COLOR, TMT_TOCOLOR4},
    {L"TOCOLOR5", TMT_COLOR, TMT_TOCOLOR5},
    {L"TOHUE1", TMT_INT, TMT_TOHUE1},
    {L"TOHUE2", TMT_INT, TMT_TOHUE2},
    {L"TOHUE3", TMT_INT, TMT_TOHUE3},
    {L"TOHUE4", TMT_INT, TMT_TOHUE4},
    {L"TOHUE5", TMT_INT, TMT_TOHUE5},
    {L"TOOLTIP", TMT_STRING, TMT_TOOLTIP},
    {L"TRANSITIONDURATIONS", TMT_INTLIST, TMT_TRANSITIONDURATIONS},
    {L"TRANSPARENT", TMT_BOOL, TMT_TRANSPARENT},
    {L"TRANSPARENTCOLOR", TMT_COLOR, TMT_TRANSPARENTCOLOR},
    {L"TRUESIZESCALINGTYPE", TMT_ENUM, TMT_TRUESIZESCALINGTYPE},
    {L"TRUESIZESTRETCHMARK", TMT_INT, TMT_TRUESIZESTRETCHMARK},
    {L"UNIFORMSIZING", TMT_BOOL, TMT_UNIFORMSIZING},
    {L"URL", TMT_STRING, TMT_URL},
    {L"USERPICTURE", TMT_BOOL, TMT_USERPICTURE},
    {L"VALIGN", TMT_ENUM, TMT_VALIGN},
    {L"VERSION", TMT_STRING, TMT_VERSION},
    {L"WIDTH", TMT_SIZE, TMT_WIDTH},
    {L"WINDOW", TMT_COLOR, TMT_WINDOW},
    {L"WINDOWFRAME", TMT_COLOR, TMT_WINDOWFRAME},
    {L"WINDOWTEXT", TMT_COLOR, TMT_WINDOWTEXT},
    {L"XMLNAME", TMT_STRING, TMT_XMLNAME},
};

static int __cdecl property_name_compare(const void *a, const void *b)
{
    const struct MSSTYLES_PROPERTY_MAP *entry = b;
    const WCHAR *name = a;
    return CompareStringOrdinal(name, -1, entry->szPropertyName, -1, TRUE) - CSTR_EQUAL;
}

/**********************************************************************
 *      MSSTYLES_LookupProperty
 *
 * Find a property ID from name
 */
BOOL MSSTYLES_LookupProperty(LPCWSTR pszPropertyName, int *dwPrimitive, int *dwId)
{
    struct MSSTYLES_PROPERTY_MAP *found;

    if (!(found = bsearch(pszPropertyName, mapProperty, ARRAY_SIZE(mapProperty),
                          sizeof(*mapProperty), property_name_compare)))
        return FALSE;

    if (dwPrimitive) *dwPrimitive = found->dwPrimitiveType;
    if (dwId) *dwId = found->dwPropertyID;
    return TRUE;
}

static int __cdecl uxini_property_name_compare(const void *a, const void *b)
{
    const struct MSSTYLES_PROPERTY_MAP *entry = b;
    const struct uxini_string name_str = {.buf = entry->szPropertyName, .len = -1};
    return uxini_string_compare(a, &name_str);
}

static BOOL uxini_lookup_property(const struct uxini_string *property_name, int *prop_type, int *prop_id)
{
    struct MSSTYLES_PROPERTY_MAP *found;

    if (!(found = bsearch(property_name, mapProperty, ARRAY_SIZE(mapProperty),
                          sizeof(*mapProperty), uxini_property_name_compare)))
        return FALSE;

    *prop_type = found->dwPrimitiveType;
    *prop_id = found->dwPropertyID;
    return TRUE;
}

struct MSSTYLES_ENUM_MAP
{
    WORD dwEnum;
    WORD dwValue;
    WCHAR szValueName[18];
};

static const struct MSSTYLES_ENUM_MAP mapEnum[] =
{
    {TMT_BGTYPE, BT_IMAGEFILE, L"IMAGEFILE"},
    {TMT_BGTYPE, BT_BORDERFILL, L"BORDERFILL"},
    {TMT_BGTYPE, BT_NONE, L"NONE"},
    {TMT_IMAGELAYOUT, IL_VERTICAL, L"VERTICAL"},
    {TMT_IMAGELAYOUT, IL_HORIZONTAL, L"HORIZONTAL"},
    {TMT_BORDERTYPE, BT_RECT, L"RECT"},
    {TMT_BORDERTYPE, BT_ROUNDRECT, L"ROUNDRECT"},
    {TMT_BORDERTYPE, BT_ELLIPSE, L"ELLIPSE"},
    {TMT_FILLTYPE, FT_SOLID, L"SOLID"},
    {TMT_FILLTYPE, FT_VERTGRADIENT, L"VERTGRADIENT"},
    {TMT_FILLTYPE, FT_HORZGRADIENT, L"HORZGRADIENT"},
    {TMT_FILLTYPE, FT_RADIALGRADIENT, L"RADIALGRADIENT"},
    {TMT_FILLTYPE, FT_TILEIMAGE, L"TILEIMAGE"},
    {TMT_SIZINGTYPE, ST_TRUESIZE, L"TRUESIZE"},
    {TMT_SIZINGTYPE, ST_STRETCH, L"STRETCH"},
    {TMT_SIZINGTYPE, ST_TILE, L"TILE"},
    {TMT_HALIGN, HA_LEFT, L"LEFT"},
    {TMT_HALIGN, HA_CENTER, L"CENTER"},
    {TMT_HALIGN, HA_RIGHT, L"RIGHT"},
    {TMT_CONTENTALIGNMENT, CA_LEFT, L"LEFT"},
    {TMT_CONTENTALIGNMENT, CA_CENTER, L"CENTER"},
    {TMT_CONTENTALIGNMENT, CA_RIGHT, L"RIGHT"},
    {TMT_VALIGN, VA_TOP, L"TOP"},
    {TMT_VALIGN, VA_CENTER, L"CENTER"},
    {TMT_VALIGN, VA_BOTTOM, L"BOTTOM"},
    {TMT_OFFSETTYPE, OT_TOPLEFT, L"TOPLEFT"},
    {TMT_OFFSETTYPE, OT_TOPRIGHT, L"TOPRIGHT"},
    {TMT_OFFSETTYPE, OT_TOPMIDDLE, L"TOPMIDDLE"},
    {TMT_OFFSETTYPE, OT_BOTTOMLEFT, L"BOTTOMLEFT"},
    {TMT_OFFSETTYPE, OT_BOTTOMRIGHT, L"BOTTOMRIGHT"},
    {TMT_OFFSETTYPE, OT_BOTTOMMIDDLE, L"BOTTOMMIDDLE"},
    {TMT_OFFSETTYPE, OT_MIDDLELEFT, L"MIDDLELEFT"},
    {TMT_OFFSETTYPE, OT_MIDDLERIGHT, L"MIDDLERIGHT"},
    {TMT_OFFSETTYPE, OT_LEFTOFCAPTION, L"LEFTOFCAPTION"},
    {TMT_OFFSETTYPE, OT_RIGHTOFCAPTION, L"RIGHTOFCAPTION"},
    {TMT_OFFSETTYPE, OT_LEFTOFLASTBUTTON, L"LEFTOFLASTBUTTON"},
    {TMT_OFFSETTYPE, OT_RIGHTOFLASTBUTTON, L"RIGHTOFLASTBUTTON"},
    {TMT_OFFSETTYPE, OT_ABOVELASTBUTTON, L"ABOVELASTBUTTON"},
    {TMT_OFFSETTYPE, OT_BELOWLASTBUTTON, L"BELOWLASTBUTTON"},
    {TMT_ICONEFFECT, ICE_NONE, L"NONE"},
    {TMT_ICONEFFECT, ICE_GLOW, L"GLOW"},
    {TMT_ICONEFFECT, ICE_SHADOW, L"SHADOW"},
    {TMT_ICONEFFECT, ICE_PULSE, L"PULSE"},
    {TMT_ICONEFFECT, ICE_ALPHA, L"ALPHA"},
    {TMT_TEXTSHADOWTYPE, TST_NONE, L"NONE"},
    {TMT_TEXTSHADOWTYPE, TST_SINGLE, L"SINGLE"},
    {TMT_TEXTSHADOWTYPE, TST_CONTINUOUS, L"CONTINUOUS"},
    {TMT_GLYPHTYPE, GT_NONE, L"NONE"},
    {TMT_GLYPHTYPE, GT_IMAGEGLYPH, L"IMAGEGLYPH"},
    {TMT_GLYPHTYPE, GT_FONTGLYPH, L"FONTGLYPH"},
    {TMT_IMAGESELECTTYPE, IST_NONE, L"NONE"},
    {TMT_IMAGESELECTTYPE, IST_SIZE, L"SIZE"},
    {TMT_IMAGESELECTTYPE, IST_DPI, L"DPI"},
    {TMT_TRUESIZESCALINGTYPE, TSST_NONE, L"NONE"},
    {TMT_TRUESIZESCALINGTYPE, TSST_SIZE, L"SIZE"},
    {TMT_TRUESIZESCALINGTYPE, TSST_DPI, L"DPI"},
    {TMT_GLYPHFONTSIZINGTYPE, GFST_NONE, L"NONE"},
    {TMT_GLYPHFONTSIZINGTYPE, GFST_SIZE, L"SIZE"},
    {TMT_GLYPHFONTSIZINGTYPE, GFST_DPI, L"DPI"},
    {0, 0, L""},
};

/**********************************************************************
 *      MSSTYLES_LookupEnum
 *
 * Lookup the value for an enumeration
 */
BOOL MSSTYLES_LookupEnum(LPCWSTR pszValueName, int dwEnum, int *dwValue)
{
    DWORD item = 0;
    /* Locate the enum block */
    while(*mapEnum[item].szValueName && mapEnum[item].dwEnum != dwEnum) item++;
    /* Now find the value in that block */
    while(*mapEnum[item].szValueName && mapEnum[item].dwEnum == dwEnum) {
        if(!lstrcmpiW(mapEnum[item].szValueName, pszValueName)) {
            if(dwValue) *dwValue = mapEnum[item].dwValue;
            return TRUE;
        }
        item++;
    }
    return FALSE;
}

struct MSSTYLES_CLASS_MAP
{
    WORD dwPartID;
    WORD dwStateID;
    WCHAR szName[31];
};

struct MSSTYLES_CLASS_NAME
{
    const struct MSSTYLES_CLASS_MAP *lpMap;
    WCHAR pszClass[12];
};

/***********************************************************************
 * Classes defined below
 * Defined as PartID,StateID,TextName
 * If StateID == 0 then its a part being defined
 */
static const struct MSSTYLES_CLASS_MAP classButton[] =
{
    {BP_PUSHBUTTON, 0, L"PUSHBUTTON"},
    {BP_PUSHBUTTON, PBS_NORMAL, L"NORMAL"},
    {BP_PUSHBUTTON, PBS_HOT, L"HOT"},
    {BP_PUSHBUTTON, PBS_PRESSED, L"PRESSED"},
    {BP_PUSHBUTTON, PBS_DISABLED, L"DISABLED"},
    {BP_PUSHBUTTON, PBS_DEFAULTED, L"DEFAULTED"},
    {BP_PUSHBUTTON, PBS_DEFAULTED_ANIMATING, L"DEFAULTED_ANIMATING"},
    {BP_RADIOBUTTON, 0, L"RADIOBUTTON"},
    {BP_RADIOBUTTON, RBS_UNCHECKEDNORMAL, L"UNCHECKEDNORMAL"},
    {BP_RADIOBUTTON, RBS_UNCHECKEDHOT, L"UNCHECKEDHOT"},
    {BP_RADIOBUTTON, RBS_UNCHECKEDPRESSED, L"UNCHECKEDPRESSED"},
    {BP_RADIOBUTTON, RBS_UNCHECKEDDISABLED, L"UNCHECKEDDISABLED"},
    {BP_RADIOBUTTON, RBS_CHECKEDNORMAL, L"CHECKEDNORMAL"},
    {BP_RADIOBUTTON, RBS_CHECKEDHOT, L"CHECKEDHOT"},
    {BP_RADIOBUTTON, RBS_CHECKEDPRESSED, L"CHECKEDPRESSED"},
    {BP_RADIOBUTTON, RBS_CHECKEDDISABLED, L"CHECKEDDISABLED"},
    {BP_CHECKBOX, 0, L"CHECKBOX"},
    {BP_CHECKBOX, CBS_UNCHECKEDNORMAL, L"UNCHECKEDNORMAL"},
    {BP_CHECKBOX, CBS_UNCHECKEDHOT, L"UNCHECKEDHOT"},
    {BP_CHECKBOX, CBS_UNCHECKEDPRESSED, L"UNCHECKEDPRESSED"},
    {BP_CHECKBOX, CBS_UNCHECKEDDISABLED, L"UNCHECKEDDISABLED"},
    {BP_CHECKBOX, CBS_CHECKEDNORMAL, L"CHECKEDNORMAL"},
    {BP_CHECKBOX, CBS_CHECKEDHOT, L"CHECKEDHOT"},
    {BP_CHECKBOX, CBS_CHECKEDPRESSED, L"CHECKEDPRESSED"},
    {BP_CHECKBOX, CBS_CHECKEDDISABLED, L"CHECKEDDISABLED"},
    {BP_CHECKBOX, CBS_MIXEDNORMAL, L"MIXEDNORMAL"},
    {BP_CHECKBOX, CBS_MIXEDHOT, L"MIXEDHOT"},
    {BP_CHECKBOX, CBS_MIXEDPRESSED, L"MIXEDPRESSED"},
    {BP_CHECKBOX, CBS_MIXEDDISABLED, L"MIXEDDISABLED"},
    {BP_CHECKBOX, CBS_IMPLICITNORMAL, L"IMPLICITNORMAL"},
    {BP_CHECKBOX, CBS_IMPLICITHOT, L"IMPLICITHOT"},
    {BP_CHECKBOX, CBS_IMPLICITPRESSED, L"IMPLICITPRESSED"},
    {BP_CHECKBOX, CBS_IMPLICITDISABLED, L"IMPLICITDISABLED"},
    {BP_CHECKBOX, CBS_EXCLUDEDNORMAL, L"EXCLUDEDNORMAL"},
    {BP_CHECKBOX, CBS_EXCLUDEDHOT, L"EXCLUDEDHOT"},
    {BP_CHECKBOX, CBS_EXCLUDEDPRESSED, L"EXCLUDEDPRESSED"},
    {BP_CHECKBOX, CBS_EXCLUDEDDISABLED, L"EXCLUDEDDISABLED"},
    {BP_GROUPBOX, 0, L"GROUPBOX"},
    {BP_GROUPBOX, GBS_NORMAL, L"NORMAL"},
    {BP_GROUPBOX, GBS_DISABLED, L"DISABLED"},
    {BP_USERBUTTON, 0, L"USERBUTTON"},
    {BP_COMMANDLINK, 0, L"COMMANDLINK"},
    {BP_COMMANDLINK, CMDLS_NORMAL, L"NORMAL"},
    {BP_COMMANDLINK, CMDLS_HOT, L"HOT"},
    {BP_COMMANDLINK, CMDLS_PRESSED, L"PRESSED"},
    {BP_COMMANDLINK, CMDLS_DISABLED, L"DISABLED"},
    {BP_COMMANDLINK, CMDLS_DEFAULTED, L"DEFAULTED"},
    {BP_COMMANDLINK, CMDLS_DEFAULTED_ANIMATING, L"DEFAULTED_ANIMATING"},
    {BP_COMMANDLINKGLYPH, 0, L"COMMANDLINKGLYPH"},
    {BP_COMMANDLINKGLYPH, CMDLGS_NORMAL, L"NORMAL"},
    {BP_COMMANDLINKGLYPH, CMDLGS_HOT, L"HOT"},
    {BP_COMMANDLINKGLYPH, CMDLGS_PRESSED, L"PRESSED"},
    {BP_COMMANDLINKGLYPH, CMDLGS_DISABLED, L"DISABLED"},
    {BP_COMMANDLINKGLYPH, CMDLGS_DEFAULTED, L"DEFAULTED"},
    {BP_RADIOBUTTON_HCDISABLED, 0, L"RADIOBUTTON_HCDISABLED"},
    {BP_RADIOBUTTON_HCDISABLED, RBS_UNCHECKEDNORMAL, L"UNCHECKEDNORMAL"},
    {BP_RADIOBUTTON_HCDISABLED, RBS_UNCHECKEDHOT, L"UNCHECKEDHOT"},
    {BP_RADIOBUTTON_HCDISABLED, RBS_UNCHECKEDPRESSED, L"UNCHECKEDPRESSED"},
    {BP_RADIOBUTTON_HCDISABLED, RBS_UNCHECKEDDISABLED, L"UNCHECKEDDISABLED"},
    {BP_RADIOBUTTON_HCDISABLED, RBS_CHECKEDNORMAL, L"CHECKEDNORMAL"},
    {BP_RADIOBUTTON_HCDISABLED, RBS_CHECKEDHOT, L"CHECKEDHOT"},
    {BP_RADIOBUTTON_HCDISABLED, RBS_CHECKEDPRESSED, L"CHECKEDPRESSED"},
    {BP_RADIOBUTTON_HCDISABLED, RBS_CHECKEDDISABLED, L"CHECKEDDISABLED"},
    {BP_CHECKBOX_HCDISABLED, 0, L"CHECKBOX_HCDISABLED"},
    {BP_CHECKBOX_HCDISABLED, CBS_UNCHECKEDNORMAL, L"UNCHECKEDNORMAL"},
    {BP_CHECKBOX_HCDISABLED, CBS_UNCHECKEDHOT, L"UNCHECKEDHOT"},
    {BP_CHECKBOX_HCDISABLED, CBS_UNCHECKEDPRESSED, L"UNCHECKEDPRESSED"},
    {BP_CHECKBOX_HCDISABLED, CBS_UNCHECKEDDISABLED, L"UNCHECKEDDISABLED"},
    {BP_CHECKBOX_HCDISABLED, CBS_CHECKEDNORMAL, L"CHECKEDNORMAL"},
    {BP_CHECKBOX_HCDISABLED, CBS_CHECKEDHOT, L"CHECKEDHOT"},
    {BP_CHECKBOX_HCDISABLED, CBS_CHECKEDPRESSED, L"CHECKEDPRESSED"},
    {BP_CHECKBOX_HCDISABLED, CBS_CHECKEDDISABLED, L"CHECKEDDISABLED"},
    {BP_CHECKBOX_HCDISABLED, CBS_MIXEDNORMAL, L"MIXEDNORMAL"},
    {BP_CHECKBOX_HCDISABLED, CBS_MIXEDHOT, L"MIXEDHOT"},
    {BP_CHECKBOX_HCDISABLED, CBS_MIXEDPRESSED, L"MIXEDPRESSED"},
    {BP_CHECKBOX_HCDISABLED, CBS_MIXEDDISABLED, L"MIXEDDISABLED"},
    {BP_CHECKBOX_HCDISABLED, CBS_IMPLICITNORMAL, L"IMPLICITNORMAL"},
    {BP_CHECKBOX_HCDISABLED, CBS_IMPLICITHOT, L"IMPLICITHOT"},
    {BP_CHECKBOX_HCDISABLED, CBS_IMPLICITPRESSED, L"IMPLICITPRESSED"},
    {BP_CHECKBOX_HCDISABLED, CBS_IMPLICITDISABLED, L"IMPLICITDISABLED"},
    {BP_CHECKBOX_HCDISABLED, CBS_EXCLUDEDNORMAL, L"EXCLUDEDNORMAL"},
    {BP_CHECKBOX_HCDISABLED, CBS_EXCLUDEDHOT, L"EXCLUDEDHOT"},
    {BP_CHECKBOX_HCDISABLED, CBS_EXCLUDEDPRESSED, L"EXCLUDEDPRESSED"},
    {BP_CHECKBOX_HCDISABLED, CBS_EXCLUDEDDISABLED, L"EXCLUDEDDISABLED"},
    {BP_GROUPBOX_HCDISABLED, 0, L"GROUPBOX_HCDISABLED"},
    {BP_GROUPBOX_HCDISABLED, GBS_NORMAL, L"NORMAL"},
    {BP_GROUPBOX_HCDISABLED, GBS_DISABLED, L"DISABLED"},
    {BP_PUSHBUTTONDROPDOWN, 0, L"PUSHBUTTONDROPDOWN"},
    {BP_PUSHBUTTONDROPDOWN, PBDDS_NORMAL, L"NORMAL"},
    {BP_PUSHBUTTONDROPDOWN, PBDDS_DISABLED, L"DISABLED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classClock[] =
{
    {CLP_TIME, 0, L"TIME"},
    {CLP_TIME, CLS_NORMAL, L"NORMAL"},
    {CLP_TIME, CLS_HOT, L"HOT"},
    {CLP_TIME, CLS_PRESSED, L"PRESSED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classCombobox[] =
{
    {CP_DROPDOWNBUTTON, 0, L"DROPDOWNBUTTON"},
    {CP_DROPDOWNBUTTON, CBXS_NORMAL, L"NORMAL"},
    {CP_DROPDOWNBUTTON, CBXS_HOT, L"HOT"},
    {CP_DROPDOWNBUTTON, CBXS_PRESSED, L"PRESSED"},
    {CP_DROPDOWNBUTTON, CBXS_DISABLED, L"DISABLED"},
    {CP_BACKGROUND, 0, L"BACKGROUND"},
    {CP_TRANSPARENTBACKGROUND, 0, L"TRANSPARENTBACKGROUND"},
    {CP_TRANSPARENTBACKGROUND, CBTBS_NORMAL, L"NORMAL"},
    {CP_TRANSPARENTBACKGROUND, CBTBS_HOT, L"HOT"},
    {CP_TRANSPARENTBACKGROUND, CBTBS_DISABLED, L"DISABLED"},
    {CP_TRANSPARENTBACKGROUND, CBTBS_FOCUSED, L"FOCUSED"},
    {CP_BORDER, 0, L"BORDER"},
    {CP_BORDER, CBB_NORMAL, L"NORMAL"},
    {CP_BORDER, CBB_HOT, L"HOT"},
    {CP_BORDER, CBB_FOCUSED, L"FOCUSED"},
    {CP_BORDER, CBB_DISABLED, L"DISABLED"},
    {CP_READONLY, 0, L"READONLY"},
    {CP_READONLY, CBRO_NORMAL, L"NORMAL"},
    {CP_READONLY, CBRO_HOT, L"HOT"},
    {CP_READONLY, CBRO_PRESSED, L"PRESSED"},
    {CP_READONLY, CBRO_DISABLED, L"DISABLED"},
    {CP_DROPDOWNBUTTONRIGHT, 0, L"DROPDOWNBUTTONRIGHT"},
    {CP_DROPDOWNBUTTONRIGHT, CBXSR_NORMAL, L"NORMAL"},
    {CP_DROPDOWNBUTTONRIGHT, CBXSR_HOT, L"HOT"},
    {CP_DROPDOWNBUTTONRIGHT, CBXSR_PRESSED, L"PRESSED"},
    {CP_DROPDOWNBUTTONRIGHT, CBXSR_DISABLED, L"DISABLED"},
    {CP_DROPDOWNBUTTONLEFT, 0, L"DROPDOWNBUTTONLEFT"},
    {CP_DROPDOWNBUTTONLEFT, CBXSL_NORMAL, L"NORMAL"},
    {CP_DROPDOWNBUTTONLEFT, CBXSL_HOT, L"HOT"},
    {CP_DROPDOWNBUTTONLEFT, CBXSL_PRESSED, L"PRESSED"},
    {CP_DROPDOWNBUTTONLEFT, CBXSL_DISABLED, L"DISABLED"},
    {CP_CUEBANNER, 0, L"CUEBANNER"},
    {CP_CUEBANNER, CBCB_NORMAL, L"NORMAL"},
    {CP_CUEBANNER, CBCB_HOT, L"HOT"},
    {CP_CUEBANNER, CBCB_PRESSED, L"PRESSED"},
    {CP_CUEBANNER, CBCB_DISABLED, L"DISABLED"},
    {CP_DROPDOWNITEM, 0, L"DROPDOWNITEM"},
    {CP_DROPDOWNITEM, CBDI_NORMAL, L"NORMAL"},
    {CP_DROPDOWNITEM, CBDI_HIGHLIGHTED, L"HIGHLIGHTED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classEdit[] =
{
    {EP_EDITTEXT, 0, L"EDITTEXT"},
    {EP_EDITTEXT, ETS_NORMAL, L"NORMAL"},
    {EP_EDITTEXT, ETS_HOT, L"HOT"},
    {EP_EDITTEXT, ETS_SELECTED, L"SELECTED"},
    {EP_EDITTEXT, ETS_DISABLED, L"DISABLED"},
    {EP_EDITTEXT, ETS_FOCUSED, L"FOCUSED"},
    {EP_EDITTEXT, ETS_READONLY, L"READONLY"},
    {EP_EDITTEXT, ETS_ASSIST, L"ASSIST"},
    {EP_EDITTEXT, ETS_CUEBANNER, L"CUEBANNER"},
    {EP_CARET, 0, L"CARET"},
    {EP_BACKGROUND, 0, L"BACKGROUND"},
    {EP_BACKGROUND, EBS_NORMAL, L"NORMAL"},
    {EP_BACKGROUND, EBS_HOT, L"HOT"},
    {EP_BACKGROUND, EBS_DISABLED, L"DISABLED"},
    {EP_BACKGROUND, EBS_FOCUSED, L"FOCUSED"},
    {EP_BACKGROUND, EBS_READONLY, L"READONLY"},
    {EP_BACKGROUND, EBS_ASSIST, L"ASSIST"},
    {EP_PASSWORD, 0, L"PASSWORD"},
    {EP_BACKGROUNDWITHBORDER, 0, L"BACKGROUNDWITHBORDER"},
    {EP_BACKGROUNDWITHBORDER, EBWBS_NORMAL, L"NORMAL"},
    {EP_BACKGROUNDWITHBORDER, EBWBS_HOT, L"HOT"},
    {EP_BACKGROUNDWITHBORDER, EBWBS_DISABLED, L"DISABLED"},
    {EP_BACKGROUNDWITHBORDER, EBWBS_FOCUSED, L"FOCUSED"},
    {EP_EDITBORDER_NOSCROLL, 0, L"EDITBORDER_NOSCROLL"},
    {EP_EDITBORDER_NOSCROLL, EPSN_NORMAL, L"NORMAL"},
    {EP_EDITBORDER_NOSCROLL, EPSN_HOT, L"HOT"},
    {EP_EDITBORDER_NOSCROLL, EPSN_FOCUSED, L"FOCUSED"},
    {EP_EDITBORDER_NOSCROLL, EPSN_DISABLED, L"DISABLED"},
    {EP_EDITBORDER_HSCROLL, 0, L"EDITBORDER_HSCROLL"},
    {EP_EDITBORDER_HSCROLL, EPSH_NORMAL, L"NORMAL"},
    {EP_EDITBORDER_HSCROLL, EPSH_HOT, L"HOT"},
    {EP_EDITBORDER_HSCROLL, EPSH_FOCUSED, L"FOCUSED"},
    {EP_EDITBORDER_HSCROLL, EPSH_DISABLED, L"DISABLED"},
    {EP_EDITBORDER_VSCROLL, 0, L"EDITBORDER_VSCROLL"},
    {EP_EDITBORDER_VSCROLL, EPSV_NORMAL, L"NORMAL"},
    {EP_EDITBORDER_VSCROLL, EPSV_HOT, L"HOT"},
    {EP_EDITBORDER_VSCROLL, EPSV_FOCUSED, L"FOCUSED"},
    {EP_EDITBORDER_VSCROLL, EPSV_DISABLED, L"DISABLED"},
    {EP_EDITBORDER_HVSCROLL, 0, L"EDITBORDER_HVSCROLL"},
    {EP_EDITBORDER_HVSCROLL, EPSHV_NORMAL, L"NORMAL"},
    {EP_EDITBORDER_HVSCROLL, EPSHV_HOT, L"HOT"},
    {EP_EDITBORDER_HVSCROLL, EPSHV_FOCUSED, L"FOCUSED"},
    {EP_EDITBORDER_HVSCROLL, EPSHV_DISABLED, L"DISABLED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classExplorerbar[] =
{
    {EBP_HEADERBACKGROUND, 0, L"HEADERBACKGROUND"},
    {EBP_HEADERCLOSE, 0, L"HEADERCLOSE"},
    {EBP_HEADERCLOSE, EBHC_NORMAL, L"NORMAL"},
    {EBP_HEADERCLOSE, EBHC_HOT, L"HOT"},
    {EBP_HEADERCLOSE, EBHC_PRESSED, L"PRESSED"},
    {EBP_HEADERPIN, 0, L"HEADERPIN"},
    {EBP_HEADERPIN, EBHP_NORMAL, L"NORMAL"},
    {EBP_HEADERPIN, EBHP_HOT, L"HOT"},
    {EBP_HEADERPIN, EBHP_PRESSED, L"PRESSED"},
    {EBP_HEADERPIN, EBHP_SELECTEDNORMAL, L"SELECTEDNORMAL"},
    {EBP_HEADERPIN, EBHP_SELECTEDHOT, L"SELECTEDHOT"},
    {EBP_HEADERPIN, EBHP_SELECTEDPRESSED, L"SELECTEDPRESSED"},
    {EBP_IEBARMENU, 0, L"IEBARMENU"},
    {EBP_IEBARMENU, EBM_NORMAL, L"NORMAL"},
    {EBP_IEBARMENU, EBM_HOT, L"HOT"},
    {EBP_IEBARMENU, EBM_PRESSED, L"PRESSED"},
    {EBP_NORMALGROUPBACKGROUND, 0, L"NORMALGROUPBACKGROUND"},
    {EBP_NORMALGROUPCOLLAPSE, 0, L"NORMALGROUPCOLLAPSE"},
    {EBP_NORMALGROUPCOLLAPSE, EBNGC_NORMAL, L"NORMAL"},
    {EBP_NORMALGROUPCOLLAPSE, EBNGC_HOT, L"HOT"},
    {EBP_NORMALGROUPCOLLAPSE, EBNGC_PRESSED, L"PRESSED"},
    {EBP_NORMALGROUPEXPAND, 0, L"NORMALGROUPEXPAND"},
    {EBP_NORMALGROUPEXPAND, EBNGE_NORMAL, L"NORMAL"},
    {EBP_NORMALGROUPEXPAND, EBNGE_HOT, L"HOT"},
    {EBP_NORMALGROUPEXPAND, EBNGE_PRESSED, L"PRESSED"},
    {EBP_NORMALGROUPHEAD, 0, L"NORMALGROUPHEAD"},
    {EBP_SPECIALGROUPBACKGROUND, 0, L"SPECIALGROUPBACKGROUND"},
    {EBP_SPECIALGROUPCOLLAPSE, 0, L"SPECIALGROUPCOLLAPSE"},
    {EBP_SPECIALGROUPCOLLAPSE, EBSGC_NORMAL, L"NORMAL"},
    {EBP_SPECIALGROUPCOLLAPSE, EBSGC_HOT, L"HOT"},
    {EBP_SPECIALGROUPCOLLAPSE, EBSGC_PRESSED, L"PRESSED"},
    {EBP_SPECIALGROUPEXPAND, 0, L"SPECIALGROUPEXPAND"},
    {EBP_SPECIALGROUPEXPAND, EBSGE_NORMAL, L"NORMAL"},
    {EBP_SPECIALGROUPEXPAND, EBSGE_HOT, L"HOT"},
    {EBP_SPECIALGROUPEXPAND, EBSGE_PRESSED, L"PRESSED"},
    {EBP_SPECIALGROUPHEAD, 0, L"SPECIALGROUPHEAD"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classHeader[] =
{
    {HP_HEADERITEM, 0, L"HEADERITEM"},
    {HP_HEADERITEM, HIS_NORMAL, L"NORMAL"},
    {HP_HEADERITEM, HIS_HOT, L"HOT"},
    {HP_HEADERITEM, HIS_PRESSED, L"PRESSED"},
    {HP_HEADERITEM, HIS_SORTEDNORMAL, L"SORTEDNORMAL"},
    {HP_HEADERITEM, HIS_SORTEDHOT, L"SORTHOT"},
    {HP_HEADERITEM, HIS_SORTEDPRESSED, L"SORTPRESSED"},
    {HP_HEADERITEM, HIS_ICONNORMAL, L"ICONNORMAL"},
    {HP_HEADERITEM, HIS_ICONHOT, L"ICONHOT"},
    {HP_HEADERITEM, HIS_ICONPRESSED, L"ICONPRESSED"},
    {HP_HEADERITEM, HIS_ICONSORTEDNORMAL, L"ICONSORTEDNORMAL"},
    {HP_HEADERITEM, HIS_ICONSORTEDHOT, L"ICONSORTEDHOT"},
    {HP_HEADERITEM, HIS_ICONSORTEDPRESSED, L"ICONSORTEDPRESSED"},
    {HP_HEADERITEMLEFT, 0, L"HEADERITEMLEFT"},
    {HP_HEADERITEMLEFT, HILS_NORMAL, L"NORMAL"},
    {HP_HEADERITEMLEFT, HILS_HOT, L"HOT"},
    {HP_HEADERITEMLEFT, HILS_PRESSED, L"PRESSED"},
    {HP_HEADERITEMRIGHT, 0, L"HEADERITEMRIGHT"},
    {HP_HEADERITEMRIGHT, HIRS_NORMAL, L"NORMAL"},
    {HP_HEADERITEMRIGHT, HIRS_HOT, L"HOT"},
    {HP_HEADERITEMRIGHT, HIRS_PRESSED, L"PRESSED"},
    {HP_HEADERSORTARROW, 0, L"HEADERSORTARROW"},
    {HP_HEADERSORTARROW, HSAS_SORTEDUP, L"SORTEDUP"},
    {HP_HEADERSORTARROW, HSAS_SORTEDDOWN, L"SORTEDDOWN"},
    {HP_HEADERDROPDOWN, 0, L"HEADERDROPDOWN"},
    {HP_HEADERDROPDOWN, HDDS_NORMAL, L"NORMAL"},
    {HP_HEADERDROPDOWN, HDDS_SOFTHOT, L"SOFTHOT"},
    {HP_HEADERDROPDOWN, HDDS_HOT, L"HOT"},
    {HP_HEADERDROPDOWNFILTER, 0, L"HEADERDROPDOWNFILTER"},
    {HP_HEADERDROPDOWNFILTER, HDDFS_NORMAL, L"NORMAL"},
    {HP_HEADERDROPDOWNFILTER, HDDFS_SOFTHOT, L"SOFTHOT"},
    {HP_HEADERDROPDOWNFILTER, HDDFS_HOT, L"HOT"},
    {HP_HEADEROVERFLOW, 0, L"HEADEROVERFLOW"},
    {HP_HEADEROVERFLOW, HOFS_NORMAL, L"NORMAL"},
    {HP_HEADEROVERFLOW, HOFS_HOT, L"HOT"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classListview[] =
{
    {LVP_LISTITEM, 0, L"LISTITEM"},
    {LVP_LISTITEM, LISS_NORMAL, L"NORMAL"},
    {LVP_LISTITEM, LISS_HOT, L"HOT"},
    {LVP_LISTITEM, LISS_SELECTED, L"SELECTED"},
    {LVP_LISTITEM, LISS_DISABLED, L"DISABLED"},
    {LVP_LISTITEM, LISS_SELECTEDNOTFOCUS, L"SELECTEDNOTFOCUS"},
    {LVP_LISTITEM, LISS_HOTSELECTED, L"HOTSELECTED"},
    {LVP_LISTGROUP, 0, L"LISTGROUP"},
    {LVP_LISTDETAIL, 0, L"LISTDETAIL"},
    {LVP_LISTSORTEDDETAIL, 0, L"LISTSORTEDDETAIL"},
    {LVP_EMPTYTEXT, 0, L"EMPTYTEXT"},
    {LVP_GROUPHEADER, 0, L"GROUPHEADER"},
    {LVP_GROUPHEADER, LVGH_OPEN, L"OPEN"},
    {LVP_GROUPHEADER, LVGH_OPENHOT, L"OPENHOT"},
    {LVP_GROUPHEADER, LVGH_OPENSELECTED, L"OPENSELECTED"},
    {LVP_GROUPHEADER, LVGH_OPENSELECTEDHOT, L"OPENSELECTEDHOT"},
    {LVP_GROUPHEADER, LVGH_OPENSELECTEDNOTFOCUSED, L"OPENSELECTEDNOTFOCUSED"},
    {LVP_GROUPHEADER, LVGH_OPENSELECTEDNOTFOCUSEDHOT, L"OPENSELECTEDNOTFOCUSEDHOT"},
    {LVP_GROUPHEADER, LVGH_OPENMIXEDSELECTION, L"OPENMIXEDSELECTION"},
    {LVP_GROUPHEADER, LVGH_OPENMIXEDSELECTIONHOT, L"OPENMIXEDSELECTIONHOT"},
    {LVP_GROUPHEADER, LVGH_CLOSE, L"CLOSE"},
    {LVP_GROUPHEADER, LVGH_CLOSEHOT, L"CLOSEHOT"},
    {LVP_GROUPHEADER, LVGH_CLOSESELECTED, L"CLOSESELECTED"},
    {LVP_GROUPHEADER, LVGH_CLOSESELECTEDHOT, L"CLOSESELECTEDHOT"},
    {LVP_GROUPHEADER, LVGH_CLOSESELECTEDNOTFOCUSED, L"CLOSESELECTEDNOTFOCUSED"},
    {LVP_GROUPHEADER, LVGH_CLOSESELECTEDNOTFOCUSEDHOT, L"CLOSESELECTEDNOTFOCUSEDHOT"},
    {LVP_GROUPHEADER, LVGH_CLOSEMIXEDSELECTION, L"CLOSEMIXEDSELECTION"},
    {LVP_GROUPHEADER, LVGH_CLOSEMIXEDSELECTIONHOT, L"CLOSEMIXEDSELECTIONHOT"},
    {LVP_GROUPHEADERLINE, 0, L"GROUPHEADERLINE"},
    {LVP_GROUPHEADERLINE, LVGHL_OPEN, L"OPEN"},
    {LVP_GROUPHEADERLINE, LVGHL_OPENHOT, L"OPENHOT"},
    {LVP_GROUPHEADERLINE, LVGHL_OPENSELECTED, L"OPENSELECTED"},
    {LVP_GROUPHEADERLINE, LVGHL_OPENSELECTEDHOT, L"OPENSELECTEDHOT"},
    {LVP_GROUPHEADERLINE, LVGHL_OPENSELECTEDNOTFOCUSED, L"OPENSELECTEDNOTFOCUSED"},
    {LVP_GROUPHEADERLINE, LVGHL_OPENSELECTEDNOTFOCUSEDHOT, L"OPENSELECTEDNOTFOCUSEDHOT"},
    {LVP_GROUPHEADERLINE, LVGHL_OPENMIXEDSELECTION, L"OPENMIXEDSELECTION"},
    {LVP_GROUPHEADERLINE, LVGHL_OPENMIXEDSELECTIONHOT, L"OPENMIXEDSELECTIONHOT"},
    {LVP_GROUPHEADERLINE, LVGHL_CLOSE, L"CLOSE"},
    {LVP_GROUPHEADERLINE, LVGHL_CLOSEHOT, L"CLOSEHOT"},
    {LVP_GROUPHEADERLINE, LVGHL_CLOSESELECTED, L"CLOSESELECTED"},
    {LVP_GROUPHEADERLINE, LVGHL_CLOSESELECTEDHOT, L"CLOSESELECTEDHOT"},
    {LVP_GROUPHEADERLINE, LVGHL_CLOSESELECTEDNOTFOCUSED, L"CLOSESELECTEDNOTFOCUSED"},
    {LVP_GROUPHEADERLINE, LVGHL_CLOSESELECTEDNOTFOCUSEDHOT, L"CLOSESELECTEDNOTFOCUSEDHOT"},
    {LVP_GROUPHEADERLINE, LVGHL_CLOSEMIXEDSELECTION, L"CLOSEMIXEDSELECTION"},
    {LVP_GROUPHEADERLINE, LVGHL_CLOSEMIXEDSELECTIONHOT, L"CLOSEMIXEDSELECTIONHOT"},
    {LVP_EXPANDBUTTON, 0, L"EXPANDBUTTON"},
    {LVP_EXPANDBUTTON, LVEB_NORMAL, L"NORMAL"},
    {LVP_EXPANDBUTTON, LVEB_HOVER, L"HOVER"},
    {LVP_EXPANDBUTTON, LVEB_PUSHED, L"PUSHED"},
    {LVP_COLLAPSEBUTTON, 0, L"COLLAPSEBUTTON"},
    {LVP_COLLAPSEBUTTON, LVCB_NORMAL, L"NORMAL"},
    {LVP_COLLAPSEBUTTON, LVCB_HOVER, L"HOVER"},
    {LVP_COLLAPSEBUTTON, LVCB_PUSHED, L"PUSHED"},
    {LVP_COLUMNDETAIL, 0, L"COLUMNDETAIL"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classMenu[] =
{
    {MENU_MENUITEM_TMSCHEMA, 0, L"MENUITEM"},
    {MENU_MENUDROPDOWN_TMSCHEMA, 0, L"MENUDROPDOWN"},
    {MENU_MENUBARITEM_TMSCHEMA, 0, L"MENUBARITEM"},
    {MENU_MENUBARDROPDOWN_TMSCHEMA, 0, L"MENUBARDROPDOWN"},
    {MENU_CHEVRON_TMSCHEMA, 0, L"CHEVRON"},
    {MENU_SEPARATOR_TMSCHEMA, 0, L"SEPARATOR"},
    {MENU_BARBACKGROUND, 0, L"BARBACKGROUND"},
    {MENU_BARBACKGROUND, MB_ACTIVE, L"ACTIVE"},
    {MENU_BARBACKGROUND, MB_INACTIVE, L"INACTIVE"},
    {MENU_BARITEM, 0, L"BARITEM"},
    {MENU_BARITEM, MBI_NORMAL, L"NORMAL"},
    {MENU_BARITEM, MBI_HOT, L"HOT"},
    {MENU_BARITEM, MBI_PUSHED, L"PUSHED"},
    {MENU_BARITEM, MBI_DISABLED, L"DISABLED"},
    {MENU_BARITEM, MBI_DISABLEDHOT, L"DISABLEDHOT"},
    {MENU_BARITEM, MBI_DISABLEDPUSHED, L"DISABLEDPUSHED"},
    {MENU_POPUPBACKGROUND, 0, L"POPUPBACKGROUND"},
    {MENU_POPUPBORDERS, 0, L"POPUPBORDERS"},
    {MENU_POPUPCHECK, 0, L"POPUPCHECK"},
    {MENU_POPUPCHECK, MC_CHECKMARKNORMAL, L"CHECKMARKNORMAL"},
    {MENU_POPUPCHECK, MC_CHECKMARKDISABLED, L"CHECKMARKDISABLED"},
    {MENU_POPUPCHECK, MC_BULLETNORMAL, L"BULLETNORMAL"},
    {MENU_POPUPCHECK, MC_BULLETDISABLED, L"BULLETDISABLED"},
    {MENU_POPUPCHECKBACKGROUND, 0, L"POPUPCHECKBACKGROUND"},
    {MENU_POPUPCHECKBACKGROUND, MCB_DISABLED, L"DISABLED"},
    {MENU_POPUPCHECKBACKGROUND, MCB_NORMAL, L"NORMAL"},
    {MENU_POPUPCHECKBACKGROUND, MCB_BITMAP, L"BITMAP"},
    {MENU_POPUPGUTTER, 0, L"POPUPGUTTER"},
    {MENU_POPUPITEM, 0, L"POPUPITEM"},
    {MENU_POPUPITEM, MPI_NORMAL, L"NORMAL"},
    {MENU_POPUPITEM, MPI_HOT, L"HOT"},
    {MENU_POPUPITEM, MPI_DISABLED, L"DISABLED"},
    {MENU_POPUPITEM, MPI_DISABLEDHOT, L"DISABLEDHOT"},
    {MENU_POPUPSEPARATOR, 0, L"POPUPSEPARATOR"},
    {MENU_POPUPSUBMENU, 0, L"POPUPSUBMENU"},
    {MENU_POPUPSUBMENU, MSM_NORMAL, L"NORMAL"},
    {MENU_POPUPSUBMENU, MSM_DISABLED, L"DISABLED"},
    {MENU_SYSTEMCLOSE, 0, L"SYSTEMCLOSE"},
    {MENU_SYSTEMCLOSE, MSYSC_NORMAL, L"NORMAL"},
    {MENU_SYSTEMCLOSE, MSYSC_DISABLED, L"DISABLED"},
    {MENU_SYSTEMMAXIMIZE, 0, L"SYSTEMMAXIMIZE"},
    {MENU_SYSTEMMAXIMIZE, MSYSMX_NORMAL, L"NORMAL"},
    {MENU_SYSTEMMAXIMIZE, MSYSMX_DISABLED, L"DISABLED"},
    {MENU_SYSTEMMINIMIZE, 0, L"SYSTEMMINIMIZE"},
    {MENU_SYSTEMMINIMIZE, MSYSMN_NORMAL, L"NORMAL"},
    {MENU_SYSTEMMINIMIZE, MSYSMN_DISABLED, L"DISABLED"},
    {MENU_SYSTEMRESTORE, 0, L"SYSTEMRESTORE"},
    {MENU_SYSTEMRESTORE, MSYSR_NORMAL, L"NORMAL"},
    {MENU_SYSTEMRESTORE, MSYSR_DISABLED, L"DISABLED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classMenuband[] =
{
    {MDP_NEWAPPBUTTON, 0, L"NEWAPPBUTTON"},
    {MDP_NEWAPPBUTTON, MDS_NORMAL, L"NORMAL"},
    {MDP_NEWAPPBUTTON, MDS_HOT, L"HOT"},
    {MDP_NEWAPPBUTTON, MDS_PRESSED, L"PRESSED"},
    {MDP_NEWAPPBUTTON, MDS_DISABLED, L"DISABLED"},
    {MDP_NEWAPPBUTTON, MDS_CHECKED, L"CHECKED"},
    {MDP_NEWAPPBUTTON, MDS_HOTCHECKED, L"HOTCHECKED"},
    {MDP_SEPERATOR, 0, L"SEPERATOR"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classNavigation[] =
{
    {NAV_BACKBUTTON, 0, L"BACKBUTTON"},
    {NAV_BACKBUTTON, NAV_BB_NORMAL, L"NORMAL"},
    {NAV_BACKBUTTON, NAV_BB_HOT, L"HOT"},
    {NAV_BACKBUTTON, NAV_BB_PRESSED, L"PRESSED"},
    {NAV_BACKBUTTON, NAV_BB_DISABLED, L"DISABLED"},
    {NAV_FORWARDBUTTON, 0, L"FORWARDBUTTON"},
    {NAV_FORWARDBUTTON, NAV_FB_NORMAL, L"NORMAL"},
    {NAV_FORWARDBUTTON, NAV_FB_HOT, L"HOT"},
    {NAV_FORWARDBUTTON, NAV_FB_PRESSED, L"PRESSED"},
    {NAV_FORWARDBUTTON, NAV_FB_DISABLED, L"DISABLED"},
    {NAV_MENUBUTTON, 0, L"MENUBUTTON"},
    {NAV_MENUBUTTON, NAV_MB_NORMAL, L"NORMAL"},
    {NAV_MENUBUTTON, NAV_MB_HOT, L"HOT"},
    {NAV_MENUBUTTON, NAV_MB_PRESSED, L"PRESSED"},
    {NAV_MENUBUTTON, NAV_MB_DISABLED, L"DISABLED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classPage[] =
{
    {PGRP_UP, 0, L"UP"},
    {PGRP_UP, UPS_NORMAL, L"NORMAL"},
    {PGRP_UP, UPS_HOT, L"HOT"},
    {PGRP_UP, UPS_PRESSED, L"PRESSED"},
    {PGRP_UP, UPS_DISABLED, L"DISABLED"},
    {PGRP_DOWN, 0, L"DOWN"},
    {PGRP_DOWN, DNS_NORMAL, L"NORMAL"},
    {PGRP_DOWN, DNS_HOT, L"HOT"},
    {PGRP_DOWN, DNS_PRESSED, L"PRESSED"},
    {PGRP_DOWN, DNS_DISABLED, L"DISABLED"},
    {PGRP_UPHORZ, 0, L"UPHORZ"},
    {PGRP_UPHORZ, UPHZS_NORMAL, L"NORMAL"},
    {PGRP_UPHORZ, UPHZS_HOT, L"HOT"},
    {PGRP_UPHORZ, UPHZS_PRESSED, L"PRESSED"},
    {PGRP_UPHORZ, UPHZS_DISABLED, L"DISABLED"},
    {PGRP_DOWNHORZ, 0, L"DOWNHORZ"},
    {PGRP_DOWNHORZ, DNHZS_NORMAL, L"NORMAL"},
    {PGRP_DOWNHORZ, DNHZS_HOT, L"HOT"},
    {PGRP_DOWNHORZ, DNHZS_PRESSED, L"PRESSED"},
    {PGRP_DOWNHORZ, DNHZS_DISABLED, L"DISABLED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classProgress[] =
{
    {PP_BAR, 0, L"BAR"},
    {PP_BARVERT, 0, L"BARVERT"},
    {PP_CHUNK, 0, L"CHUNK"},
    {PP_CHUNKVERT, 0, L"CHUNKVERT"},
    {PP_FILL, 0, L"FILL"},
    {PP_FILL, PBFS_NORMAL, L"NORMAL"},
    {PP_FILL, PBFS_ERROR, L"ERROR"},
    {PP_FILL, PBFS_PAUSED, L"PAUSED"},
    {PP_FILL, PBFS_PARTIAL, L"PARTIAL"},
    {PP_FILLVERT, 0, L"FILLVERT"},
    {PP_FILLVERT, PBFVS_NORMAL, L"NORMAL"},
    {PP_FILLVERT, PBFVS_ERROR, L"ERROR"},
    {PP_FILLVERT, PBFVS_PAUSED, L"PAUSED"},
    {PP_FILLVERT, PBFVS_PARTIAL, L"PARTIAL"},
    {PP_PULSEOVERLAY, 0, L"PULSEOVERLAY"},
    {PP_MOVEOVERLAY, 0, L"MOVEOVERLAY"},
    {PP_PULSEOVERLAYVERT, 0, L"PULSEOVERLAYVERT"},
    {PP_MOVEOVERLAYVERT, 0, L"MOVEOVERLAYVERT"},
    {PP_TRANSPARENTBAR, 0, L"TRANSPARENTBAR"},
    {PP_TRANSPARENTBAR, PBBS_NORMAL, L"NORMAL"},
    {PP_TRANSPARENTBAR, PBBS_PARTIAL, L"PARTIAL"},
    {PP_TRANSPARENTBARVERT, 0, L"TRANSPARENTBARVERT"},
    {PP_TRANSPARENTBARVERT, PBBVS_NORMAL, L"NORMAL"},
    {PP_TRANSPARENTBARVERT, PBBVS_PARTIAL, L"PARTIAL"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classRebar[] =
{
    {RP_GRIPPER, 0, L"GRIPPER"},
    {RP_GRIPPERVERT, 0, L"GRIPPERVERT"},
    {RP_BAND, 0, L"BAND"},
    {RP_CHEVRON, 0, L"CHEVRON"},
    {RP_CHEVRON, CHEVS_NORMAL, L"NORMAL"},
    {RP_CHEVRON, CHEVS_HOT, L"HOT"},
    {RP_CHEVRON, CHEVS_PRESSED, L"PRESSED"},
    {RP_CHEVRONVERT, 0, L"CHEVRONVERT"},
    {RP_CHEVRONVERT, CHEVSV_NORMAL, L"NORMAL"},
    {RP_CHEVRONVERT, CHEVSV_HOT, L"HOT"},
    {RP_CHEVRONVERT, CHEVSV_PRESSED, L"PRESSED"},
    {RP_BACKGROUND, 0, L"BACKGROUND"},
    {RP_SPLITTER, 0, L"SPLITTER"},
    {RP_SPLITTER, SPLITS_NORMAL, L"NORMAL"},
    {RP_SPLITTER, SPLITS_HOT, L"HOT"},
    {RP_SPLITTER, SPLITS_PRESSED, L"PRESSED"},
    {RP_SPLITTERVERT, 0, L"SPLITTERVERT"},
    {RP_SPLITTERVERT, SPLITSV_NORMAL, L"NORMAL"},
    {RP_SPLITTERVERT, SPLITSV_HOT, L"HOT"},
    {RP_SPLITTERVERT, SPLITSV_PRESSED, L"PRESSED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classScrollbar[] =
{
    {SBP_ARROWBTN, 0, L"ARROWBTN"},
    {SBP_ARROWBTN, ABS_UPNORMAL, L"UPNORMAL"},
    {SBP_ARROWBTN, ABS_UPHOT, L"UPHOT"},
    {SBP_ARROWBTN, ABS_UPPRESSED, L"UPPRESSED"},
    {SBP_ARROWBTN, ABS_UPDISABLED, L"UPDISABLED"},
    {SBP_ARROWBTN, ABS_DOWNNORMAL, L"DOWNNORMAL"},
    {SBP_ARROWBTN, ABS_DOWNHOT, L"DOWNHOT"},
    {SBP_ARROWBTN, ABS_DOWNPRESSED, L"DOWNPRESSED"},
    {SBP_ARROWBTN, ABS_DOWNDISABLED, L"DOWNDISABLED"},
    {SBP_ARROWBTN, ABS_LEFTNORMAL, L"LEFTNORMAL"},
    {SBP_ARROWBTN, ABS_LEFTHOT, L"LEFTHOT"},
    {SBP_ARROWBTN, ABS_LEFTPRESSED, L"LEFTPRESSED"},
    {SBP_ARROWBTN, ABS_LEFTDISABLED, L"LEFTDISABLED"},
    {SBP_ARROWBTN, ABS_RIGHTNORMAL, L"RIGHTNORMAL"},
    {SBP_ARROWBTN, ABS_RIGHTHOT, L"RIGHTHOT"},
    {SBP_ARROWBTN, ABS_RIGHTPRESSED, L"RIGHTPRESSED"},
    {SBP_ARROWBTN, ABS_RIGHTDISABLED, L"RIGHTDISABLED"},
    {SBP_ARROWBTN, ABS_UPHOVER, L"UPHOVER"},
    {SBP_ARROWBTN, ABS_DOWNHOVER, L"DOWNHOVER"},
    {SBP_ARROWBTN, ABS_LEFTHOVER, L"LEFTHOVER"},
    {SBP_ARROWBTN, ABS_RIGHTHOVER, L"RIGHTHOVER"},
    {SBP_THUMBBTNHORZ, 0, L"THUMBBTNHORZ"},
    {SBP_THUMBBTNHORZ, SCRBS_NORMAL, L"NORMAL"},
    {SBP_THUMBBTNHORZ, SCRBS_HOT, L"HOT"},
    {SBP_THUMBBTNHORZ, SCRBS_PRESSED, L"PRESSED"},
    {SBP_THUMBBTNHORZ, SCRBS_DISABLED, L"DISABLED"},
    {SBP_THUMBBTNHORZ, SCRBS_HOVER, L"HOVER"},
    {SBP_THUMBBTNVERT, 0, L"THUMBBTNVERT"},
    {SBP_THUMBBTNVERT, SCRBS_NORMAL, L"NORMAL"},
    {SBP_THUMBBTNVERT, SCRBS_HOT, L"HOT"},
    {SBP_THUMBBTNVERT, SCRBS_PRESSED, L"PRESSED"},
    {SBP_THUMBBTNVERT, SCRBS_DISABLED, L"DISABLED"},
    {SBP_THUMBBTNVERT, SCRBS_HOVER, L"HOVER"},
    {SBP_LOWERTRACKHORZ, 0, L"LOWERTRACKHORZ"},
    {SBP_LOWERTRACKHORZ, SCRBS_NORMAL, L"NORMAL"},
    {SBP_LOWERTRACKHORZ, SCRBS_HOT, L"HOT"},
    {SBP_LOWERTRACKHORZ, SCRBS_PRESSED, L"PRESSED"},
    {SBP_LOWERTRACKHORZ, SCRBS_DISABLED, L"DISABLED"},
    {SBP_LOWERTRACKHORZ, SCRBS_HOVER, L"HOVER"},
    {SBP_UPPERTRACKHORZ, 0, L"UPPERTRACKHORZ"},
    {SBP_UPPERTRACKHORZ, SCRBS_NORMAL, L"NORMAL"},
    {SBP_UPPERTRACKHORZ, SCRBS_HOT, L"HOT"},
    {SBP_UPPERTRACKHORZ, SCRBS_PRESSED, L"PRESSED"},
    {SBP_UPPERTRACKHORZ, SCRBS_DISABLED, L"DISABLED"},
    {SBP_UPPERTRACKHORZ, SCRBS_HOVER, L"HOVER"},
    {SBP_LOWERTRACKVERT, 0, L"LOWERTRACKVERT"},
    {SBP_LOWERTRACKVERT, SCRBS_NORMAL, L"NORMAL"},
    {SBP_LOWERTRACKVERT, SCRBS_HOT, L"HOT"},
    {SBP_LOWERTRACKVERT, SCRBS_PRESSED, L"PRESSED"},
    {SBP_LOWERTRACKVERT, SCRBS_DISABLED, L"DISABLED"},
    {SBP_LOWERTRACKVERT, SCRBS_HOVER, L"HOVER"},
    {SBP_UPPERTRACKVERT, 0, L"UPPERTRACKVERT"},
    {SBP_UPPERTRACKVERT, SCRBS_NORMAL, L"NORMAL"},
    {SBP_UPPERTRACKVERT, SCRBS_HOT, L"HOT"},
    {SBP_UPPERTRACKVERT, SCRBS_PRESSED, L"PRESSED"},
    {SBP_UPPERTRACKVERT, SCRBS_DISABLED, L"DISABLED"},
    {SBP_UPPERTRACKVERT, SCRBS_HOVER, L"HOVER"},
    {SBP_GRIPPERHORZ, 0, L"GRIPPERHORZ"},
    {SBP_GRIPPERHORZ, SCRBS_NORMAL, L"NORMAL"},
    {SBP_GRIPPERHORZ, SCRBS_HOT, L"HOT"},
    {SBP_GRIPPERHORZ, SCRBS_PRESSED, L"PRESSED"},
    {SBP_GRIPPERHORZ, SCRBS_DISABLED, L"DISABLED"},
    {SBP_GRIPPERHORZ, SCRBS_HOVER, L"HOVER"},
    {SBP_GRIPPERVERT, 0, L"GRIPPERVERT"},
    {SBP_GRIPPERVERT, SCRBS_NORMAL, L"NORMAL"},
    {SBP_GRIPPERVERT, SCRBS_HOT, L"HOT"},
    {SBP_GRIPPERVERT, SCRBS_PRESSED, L"PRESSED"},
    {SBP_GRIPPERVERT, SCRBS_DISABLED, L"DISABLED"},
    {SBP_GRIPPERVERT, SCRBS_HOVER, L"HOVER"},
    {SBP_SIZEBOX, 0, L"SIZEBOX"},
    {SBP_SIZEBOX, SZB_RIGHTALIGN, L"RIGHTALIGN"},
    {SBP_SIZEBOX, SZB_LEFTALIGN, L"LEFTALIGN"},
    {SBP_SIZEBOX, SZB_TOPRIGHTALIGN, L"TOPRIGHTALIGN"},
    {SBP_SIZEBOX, SZB_TOPLEFTALIGN, L"TOPLEFTALIGN"},
    {SBP_SIZEBOX, SZB_HALFBOTTOMRIGHTALIGN, L"HALFBOTTOMRIGHTALIGN"},
    {SBP_SIZEBOX, SZB_HALFBOTTOMLEFTALIGN, L"HALFBOTTOMLEFTALIGN"},
    {SBP_SIZEBOX, SZB_HALFTOPRIGHTALIGN, L"HALFTOPRIGHTALIGN"},
    {SBP_SIZEBOX, SZB_HALFTOPLEFTALIGN, L"HALFTOPLEFTALIGN"},
    {SBP_SIZEBOXBKGND, 0, L"SIZEBOXBKGND"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classSpin[] =
{
    {SPNP_UP, 0, L"UP"},
    {SPNP_UP, UPS_NORMAL, L"NORMAL"},
    {SPNP_UP, UPS_HOT, L"HOT"},
    {SPNP_UP, UPS_PRESSED, L"PRESSED"},
    {SPNP_UP, UPS_DISABLED, L"DISABLED"},
    {SPNP_DOWN, 0, L"DOWN"},
    {SPNP_DOWN, DNS_NORMAL, L"NORMAL"},
    {SPNP_DOWN, DNS_HOT, L"HOT"},
    {SPNP_DOWN, DNS_PRESSED, L"PRESSED"},
    {SPNP_DOWN, DNS_DISABLED, L"DISABLED"},
    {SPNP_UPHORZ, 0, L"UPHORZ"},
    {SPNP_UPHORZ, UPHZS_NORMAL, L"NORMAL"},
    {SPNP_UPHORZ, UPHZS_HOT, L"HOT"},
    {SPNP_UPHORZ, UPHZS_PRESSED, L"PRESSED"},
    {SPNP_UPHORZ, UPHZS_DISABLED, L"DISABLED"},
    {SPNP_DOWNHORZ, 0, L"DOWNHORZ"},
    {SPNP_DOWNHORZ, DNHZS_NORMAL, L"NORMAL"},
    {SPNP_DOWNHORZ, DNHZS_HOT, L"HOT"},
    {SPNP_DOWNHORZ, DNHZS_PRESSED, L"PRESSED"},
    {SPNP_DOWNHORZ, DNHZS_DISABLED, L"DISABLED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classStartpanel[] =
{
    {SPP_USERPANE, 0, L"USERPANE"},
    {SPP_MOREPROGRAMS, 0, L"MOREPROGRAMS"},
    {SPP_MOREPROGRAMSARROW, 0, L"MOREPROGRAMSARROW"},
    {SPP_MOREPROGRAMSARROW, SPS_NORMAL, L"NORMAL"},
    {SPP_MOREPROGRAMSARROW, SPS_HOT, L"HOT"},
    {SPP_MOREPROGRAMSARROW, SPS_PRESSED, L"PRESSED"},
    {SPP_PROGLIST, 0, L"PROGLIST"},
    {SPP_PROGLISTSEPARATOR, 0, L"PROGLISTSEPARATOR"},
    {SPP_PLACESLIST, 0, L"PLACESLIST"},
    {SPP_PLACESLISTSEPARATOR, 0, L"PLACESLISTSEPARATOR"},
    {SPP_LOGOFF, 0, L"LOGOFF"},
    {SPP_LOGOFFBUTTONS, 0, L"LOGOFFBUTTONS"},
    {SPP_LOGOFFBUTTONS, SPLS_NORMAL, L"NORMAL"},
    {SPP_LOGOFFBUTTONS, SPLS_HOT, L"HOT"},
    {SPP_LOGOFFBUTTONS, SPLS_PRESSED, L"PRESSED"},
    {SPP_USERPICTURE, 0, L"USERPICTURE"},
    {SPP_PREVIEW, 0, L"PREVIEW"},
    {SPP_MOREPROGRAMSTAB, 0, L"MOREPROGRAMSTAB"},
    {SPP_MOREPROGRAMSTAB, SPMPT_NORMAL, L"NORMAL"},
    {SPP_MOREPROGRAMSTAB, SPMPT_HOT, L"HOT"},
    {SPP_MOREPROGRAMSTAB, SPMPT_SELECTED, L"SELECTED"},
    {SPP_MOREPROGRAMSTAB, SPMPT_DISABLED, L"DISABLED"},
    {SPP_MOREPROGRAMSTAB, SPMPT_FOCUSED, L"FOCUSED"},
    {SPP_NSCHOST, 0, L"NSCHOST"},
    {SPP_SOFTWAREEXPLORER, 0, L"SOFTWAREEXPLORER"},
    {SPP_SOFTWAREEXPLORER, SPSE_NORMAL, L"NORMAL"},
    {SPP_SOFTWAREEXPLORER, SPSE_HOT, L"HOT"},
    {SPP_SOFTWAREEXPLORER, SPSE_SELECTED, L"SELECTED"},
    {SPP_SOFTWAREEXPLORER, SPSE_DISABLED, L"DISABLED"},
    {SPP_SOFTWAREEXPLORER, SPSE_FOCUSED, L"FOCUSED"},
    {SPP_OPENBOX, 0, L"OPENBOX"},
    {SPP_OPENBOX, SPOB_NORMAL, L"NORMAL"},
    {SPP_OPENBOX, SPOB_HOT, L"HOT"},
    {SPP_OPENBOX, SPOB_SELECTED, L"SELECTED"},
    {SPP_OPENBOX, SPOB_DISABLED, L"DISABLED"},
    {SPP_OPENBOX, SPOB_FOCUSED, L"FOCUSED"},
    {SPP_SEARCHVIEW, 0, L"SEARCHVIEW"},
    {SPP_MOREPROGRAMSARROWBACK, 0, L"MOREPROGRAMSARROWBACK"},
    {SPP_MOREPROGRAMSARROWBACK, SPSB_NORMAL, L"NORMAL"},
    {SPP_MOREPROGRAMSARROWBACK, SPSB_HOT, L"HOT"},
    {SPP_MOREPROGRAMSARROWBACK, SPSB_PRESSED, L"PRESSED"},
    {SPP_TOPMATCH, 0, L"TOPMATCH"},
    {SPP_LOGOFFSPLITBUTTONDROPDOWN, 0, L"LOGOFFSPLITBUTTONDROPDOWN"},
    {SPP_LOGOFFSPLITBUTTONDROPDOWN, SPLS_NORMAL, L"NORMAL"},
    {SPP_LOGOFFSPLITBUTTONDROPDOWN, SPLS_HOT, L"HOT"},
    {SPP_LOGOFFSPLITBUTTONDROPDOWN, SPLS_PRESSED, L"PRESSED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classStatus[] =
{
    {SP_PANE, 0, L"PANE"},
    {SP_GRIPPERPANE, 0, L"GRIPPERPANE"},
    {SP_GRIPPER, 0, L"GRIPPER"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classTab[] =
{
    {TABP_TABITEM, 0, L"TABITEM"},
    {TABP_TABITEM, TIS_NORMAL, L"NORMAL"},
    {TABP_TABITEM, TIS_HOT, L"HOT"},
    {TABP_TABITEM, TIS_SELECTED, L"SELECTED"},
    {TABP_TABITEM, TIS_DISABLED, L"DISABLED"},
    {TABP_TABITEM, TIS_FOCUSED, L"FOCUSED"},
    {TABP_TABITEMLEFTEDGE, 0, L"TABITEMLEFTEDGE"},
    {TABP_TABITEMLEFTEDGE, TILES_NORMAL, L"NORMAL"},
    {TABP_TABITEMLEFTEDGE, TILES_HOT, L"HOT"},
    {TABP_TABITEMLEFTEDGE, TILES_SELECTED, L"SELECTED"},
    {TABP_TABITEMLEFTEDGE, TILES_DISABLED, L"DISABLED"},
    {TABP_TABITEMLEFTEDGE, TILES_FOCUSED, L"FOCUSED"},
    {TABP_TABITEMRIGHTEDGE, 0, L"TABITEMRIGHTEDGE"},
    {TABP_TABITEMRIGHTEDGE, TIRES_NORMAL, L"NORMAL"},
    {TABP_TABITEMRIGHTEDGE, TIRES_HOT, L"HOT"},
    {TABP_TABITEMRIGHTEDGE, TIRES_SELECTED, L"SELECTED"},
    {TABP_TABITEMRIGHTEDGE, TIRES_DISABLED, L"DISABLED"},
    {TABP_TABITEMRIGHTEDGE, TIRES_FOCUSED, L"FOCUSED"},
    {TABP_TABITEMBOTHEDGE, 0, L"TABITEMBOTHEDGE"},
    {TABP_TABITEMBOTHEDGE, TIBES_NORMAL, L"NORMAL"},
    {TABP_TABITEMBOTHEDGE, TIBES_HOT, L"HOT"},
    {TABP_TABITEMBOTHEDGE, TIBES_SELECTED, L"SELECTED"},
    {TABP_TABITEMBOTHEDGE, TIBES_DISABLED, L"DISABLED"},
    {TABP_TABITEMBOTHEDGE, TIBES_FOCUSED, L"FOCUSED"},
    {TABP_TOPTABITEM, 0, L"TOPTABITEM"},
    {TABP_TOPTABITEM, TTIS_NORMAL, L"NORMAL"},
    {TABP_TOPTABITEM, TTIS_HOT, L"HOT"},
    {TABP_TOPTABITEM, TTIS_SELECTED, L"SELECTED"},
    {TABP_TOPTABITEM, TTIS_DISABLED, L"DISABLED"},
    {TABP_TOPTABITEM, TTIS_FOCUSED, L"FOCUSED"},
    {TABP_TOPTABITEMLEFTEDGE, 0, L"TOPTABITEMLEFTEDGE"},
    {TABP_TOPTABITEMLEFTEDGE, TTILES_NORMAL, L"NORMAL"},
    {TABP_TOPTABITEMLEFTEDGE, TTILES_HOT, L"HOT"},
    {TABP_TOPTABITEMLEFTEDGE, TTILES_SELECTED, L"SELECTED"},
    {TABP_TOPTABITEMLEFTEDGE, TTILES_DISABLED, L"DISABLED"},
    {TABP_TOPTABITEMLEFTEDGE, TTILES_FOCUSED, L"FOCUSED"},
    {TABP_TOPTABITEMRIGHTEDGE, 0, L"TOPTABITEMRIGHTEDGE"},
    {TABP_TOPTABITEMRIGHTEDGE, TTIRES_NORMAL, L"NORMAL"},
    {TABP_TOPTABITEMRIGHTEDGE, TTIRES_HOT, L"HOT"},
    {TABP_TOPTABITEMRIGHTEDGE, TTIRES_SELECTED, L"SELECTED"},
    {TABP_TOPTABITEMRIGHTEDGE, TTIRES_DISABLED, L"DISABLED"},
    {TABP_TOPTABITEMRIGHTEDGE, TTIRES_FOCUSED, L"FOCUSED"},
    {TABP_TOPTABITEMBOTHEDGE, 0, L"TOPTABITEMBOTHEDGE"},
    {TABP_TOPTABITEMBOTHEDGE, TTIBES_NORMAL, L"NORMAL"},
    {TABP_TOPTABITEMBOTHEDGE, TTIBES_HOT, L"HOT"},
    {TABP_TOPTABITEMBOTHEDGE, TTIBES_SELECTED, L"SELECTED"},
    {TABP_TOPTABITEMBOTHEDGE, TTIBES_DISABLED, L"DISABLED"},
    {TABP_TOPTABITEMBOTHEDGE, TTIBES_FOCUSED, L"FOCUSED"},
    {TABP_PANE, 0, L"PANE"},
    {TABP_BODY, 0, L"BODY"},
    {TABP_AEROWIZARDBODY, 0, L"AEROWIZARDBODY"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classTaskband[] =
{
    {TDP_GROUPCOUNT, 0, L"GROUPCOUNT"},
    {TDP_FLASHBUTTON, 0, L"FLASHBUTTON"},
    {TDP_FLASHBUTTONGROUPMENU, 0, L"FLASHBUTTONGROUPMENU"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classTaskbar[] =
{
    {TBP_BACKGROUNDBOTTOM, 0, L"BACKGROUNDBOTTOM"},
    {TBP_BACKGROUNDRIGHT, 0, L"BACKGROUNDRIGHT"},
    {TBP_BACKGROUNDTOP, 0, L"BACKGROUNDTOP"},
    {TBP_BACKGROUNDLEFT, 0, L"BACKGROUNDLEFT"},
    {TBP_SIZINGBARBOTTOM, 0, L"SIZINGBARBOTTOM"},
    {TBP_SIZINGBARRIGHT, 0, L"SIZINGBARRIGHT"},
    {TBP_SIZINGBARTOP, 0, L"SIZINGBARTOP"},
    {TBP_SIZINGBARLEFT, 0, L"SIZINGBARLEFT"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classTaskdialog[] =
{
    {TDLG_PRIMARYPANEL, 0, L"PRIMARYPANEL"},
    {TDLG_MAININSTRUCTIONPANE, 0, L"MAININSTRUCTIONPANE"},
    {TDLG_MAINICON, 0, L"MAINICON"},
    {TDLG_CONTENTPANE, 0, L"CONTENTPANE"},
    {TDLG_CONTENTICON, 0, L"CONTENTICON"},
    {TDLG_EXPANDEDCONTENT, 0, L"EXPANDEDCONTENT"},
    {TDLG_COMMANDLINKPANE, 0, L"COMMANDLINKPANE"},
    {TDLG_SECONDARYPANEL, 0, L"SECONDARYPANEL"},
    {TDLG_CONTROLPANE, 0, L"CONTROLPANE"},
    {TDLG_CONTROLPANE, TDLGCPS_STANDALONE, L"STANDALONE"},
    {TDLG_BUTTONSECTION, 0, L"BUTTONSECTION"},
    {TDLG_BUTTONWRAPPER, 0, L"BUTTONWRAPPER"},
    {TDLG_EXPANDOTEXT, 0, L"EXPANDOTEXT"},
    {TDLG_EXPANDOBUTTON, 0, L"EXPANDOBUTTON"},
    {TDLG_EXPANDOBUTTON, TDLGEBS_NORMAL, L"NORMAL"},
    {TDLG_EXPANDOBUTTON, TDLGEBS_HOVER, L"HOVER"},
    {TDLG_EXPANDOBUTTON, TDLGEBS_PRESSED, L"PRESSED"},
    {TDLG_EXPANDOBUTTON, TDLGEBS_EXPANDEDNORMAL, L"EXPANDEDNORMAL"},
    {TDLG_EXPANDOBUTTON, TDLGEBS_EXPANDEDHOVER, L"EXPANDEDHOVER"},
    {TDLG_EXPANDOBUTTON, TDLGEBS_EXPANDEDPRESSED, L"EXPANDEDPRESSED"},
    {TDLG_EXPANDOBUTTON, TDLGEBS_NORMALDISABLED, L"NORMALDISABLED"},
    {TDLG_EXPANDOBUTTON, TDLGEBS_EXPANDEDDISABLED, L"EXPANDEDDISABLED"},
    {TDLG_VERIFICATIONTEXT, 0, L"VERIFICATIONTEXT"},
    {TDLG_FOOTNOTEPANE, 0, L"FOOTNOTEPANE"},
    {TDLG_FOOTNOTEAREA, 0, L"FOOTNOTEAREA"},
    {TDLG_FOOTNOTESEPARATOR, 0, L"FOOTNOTESEPARATOR"},
    {TDLG_EXPANDEDFOOTERAREA, 0, L"EXPANDEDFOOTERAREA"},
    {TDLG_PROGRESSBAR, 0, L"PROGRESSBAR"},
    {TDLG_IMAGEALIGNMENT, 0, L"IMAGEALIGNMENT"},
    {TDLG_RADIOBUTTONPANE, 0, L"RADIOBUTTONPANE"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classToolbar[] =
{
    {TP_BUTTON, 0, L"BUTTON"},
    {TP_BUTTON, TS_NORMAL, L"NORMAL"},
    {TP_BUTTON, TS_HOT, L"HOT"},
    {TP_BUTTON, TS_PRESSED, L"PRESSED"},
    {TP_BUTTON, TS_DISABLED, L"DISABLED"},
    {TP_BUTTON, TS_CHECKED, L"CHECKED"},
    {TP_BUTTON, TS_HOTCHECKED, L"HOTCHECKED"},
    {TP_BUTTON, TS_NEARHOT, L"NEARHOT"},
    {TP_BUTTON, TS_OTHERSIDEHOT, L"OTHERSIDEHOT"},
    {TP_DROPDOWNBUTTON, 0, L"DROPDOWNBUTTON"},
    {TP_DROPDOWNBUTTON, TS_NORMAL, L"NORMAL"},
    {TP_DROPDOWNBUTTON, TS_HOT, L"HOT"},
    {TP_DROPDOWNBUTTON, TS_PRESSED, L"PRESSED"},
    {TP_DROPDOWNBUTTON, TS_DISABLED, L"DISABLED"},
    {TP_DROPDOWNBUTTON, TS_CHECKED, L"CHECKED"},
    {TP_DROPDOWNBUTTON, TS_HOTCHECKED, L"HOTCHECKED"},
    {TP_DROPDOWNBUTTON, TS_NEARHOT, L"NEARHOT"},
    {TP_DROPDOWNBUTTON, TS_OTHERSIDEHOT, L"OTHERSIDEHOT"},
    {TP_SPLITBUTTON, 0, L"SPLITBUTTON"},
    {TP_SPLITBUTTON, TS_NORMAL, L"NORMAL"},
    {TP_SPLITBUTTON, TS_HOT, L"HOT"},
    {TP_SPLITBUTTON, TS_PRESSED, L"PRESSED"},
    {TP_SPLITBUTTON, TS_DISABLED, L"DISABLED"},
    {TP_SPLITBUTTON, TS_CHECKED, L"CHECKED"},
    {TP_SPLITBUTTON, TS_HOTCHECKED, L"HOTCHECKED"},
    {TP_SPLITBUTTON, TS_NEARHOT, L"NEARHOT"},
    {TP_SPLITBUTTON, TS_OTHERSIDEHOT, L"OTHERSIDEHOT"},
    {TP_SPLITBUTTONDROPDOWN, 0, L"SPLITBUTTONDROPDOWN"},
    {TP_SPLITBUTTONDROPDOWN, TS_NORMAL, L"NORMAL"},
    {TP_SPLITBUTTONDROPDOWN, TS_HOT, L"HOT"},
    {TP_SPLITBUTTONDROPDOWN, TS_PRESSED, L"PRESSED"},
    {TP_SPLITBUTTONDROPDOWN, TS_DISABLED, L"DISABLED"},
    {TP_SPLITBUTTONDROPDOWN, TS_CHECKED, L"CHECKED"},
    {TP_SPLITBUTTONDROPDOWN, TS_HOTCHECKED, L"HOTCHECKED"},
    {TP_SPLITBUTTONDROPDOWN, TS_NEARHOT, L"NEARHOT"},
    {TP_SPLITBUTTONDROPDOWN, TS_OTHERSIDEHOT, L"OTHERSIDEHOT"},
    {TP_SEPARATOR, 0, L"SEPARATOR"},
    {TP_SEPARATOR, TS_NORMAL, L"NORMAL"},
    {TP_SEPARATOR, TS_HOT, L"HOT"},
    {TP_SEPARATOR, TS_PRESSED, L"PRESSED"},
    {TP_SEPARATOR, TS_DISABLED, L"DISABLED"},
    {TP_SEPARATOR, TS_CHECKED, L"CHECKED"},
    {TP_SEPARATOR, TS_HOTCHECKED, L"HOTCHECKED"},
    {TP_SEPARATOR, TS_NEARHOT, L"NEARHOT"},
    {TP_SEPARATOR, TS_OTHERSIDEHOT, L"OTHERSIDEHOT"},
    {TP_SEPARATORVERT, 0, L"SEPARATORVERT"},
    {TP_SEPARATORVERT, TS_NORMAL, L"NORMAL"},
    {TP_SEPARATORVERT, TS_HOT, L"HOT"},
    {TP_SEPARATORVERT, TS_PRESSED, L"PRESSED"},
    {TP_SEPARATORVERT, TS_DISABLED, L"DISABLED"},
    {TP_SEPARATORVERT, TS_CHECKED, L"CHECKED"},
    {TP_SEPARATORVERT, TS_HOTCHECKED, L"HOTCHECKED"},
    {TP_SEPARATORVERT, TS_NEARHOT, L"NEARHOT"},
    {TP_SEPARATORVERT, TS_OTHERSIDEHOT, L"OTHERSIDEHOT"},
    {TP_DROPDOWNBUTTONGLYPH, 0, L"DROPDOWNBUTTONGLYPH"},
    {TP_DROPDOWNBUTTONGLYPH, TS_NORMAL, L"NORMAL"},
    {TP_DROPDOWNBUTTONGLYPH, TS_HOT, L"HOT"},
    {TP_DROPDOWNBUTTONGLYPH, TS_PRESSED, L"PRESSED"},
    {TP_DROPDOWNBUTTONGLYPH, TS_DISABLED, L"DISABLED"},
    {TP_DROPDOWNBUTTONGLYPH, TS_CHECKED, L"CHECKED"},
    {TP_DROPDOWNBUTTONGLYPH, TS_HOTCHECKED, L"HOTCHECKED"},
    {TP_DROPDOWNBUTTONGLYPH, TS_NEARHOT, L"NEARHOT"},
    {TP_DROPDOWNBUTTONGLYPH, TS_OTHERSIDEHOT, L"OTHERSIDEHOT"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classTooltip[] =
{
    {TTP_STANDARD, 0, L"STANDARD"},
    {TTP_STANDARD, TTSS_NORMAL, L"NORMAL"},
    {TTP_STANDARD, TTSS_LINK, L"LINK"},
    {TTP_STANDARDTITLE, 0, L"STANDARDTITLE"},
    {TTP_STANDARDTITLE, TTSS_NORMAL, L"NORMAL"},
    {TTP_STANDARDTITLE, TTSS_LINK, L"LINK"},
    {TTP_BALLOON, 0, L"BALLOON"},
    {TTP_BALLOON, TTBS_NORMAL, L"NORMAL"},
    {TTP_BALLOON, TTBS_LINK, L"LINK"},
    {TTP_BALLOONTITLE, 0, L"BALLOONTITLE"},
    {TTP_BALLOONTITLE, TTBS_NORMAL, L"NORMAL"},
    {TTP_BALLOONTITLE, TTBS_LINK, L"LINK"},
    {TTP_CLOSE, 0, L"CLOSE"},
    {TTP_CLOSE, TTCS_NORMAL, L"NORMAL"},
    {TTP_CLOSE, TTCS_HOT, L"HOT"},
    {TTP_CLOSE, TTCS_PRESSED, L"PRESSED"},
    {TTP_BALLOONSTEM, 0, L"BALLOONSTEM"},
    {TTP_BALLOONSTEM, TTBSS_POINTINGUPLEFTWALL, L"POINTINGUPLEFTWALL"},
    {TTP_BALLOONSTEM, TTBSS_POINTINGUPCENTERED, L"POINTINGUPCENTERED"},
    {TTP_BALLOONSTEM, TTBSS_POINTINGUPRIGHTWALL, L"POINTINGUPRIGHTWALL"},
    {TTP_BALLOONSTEM, TTBSS_POINTINGDOWNRIGHTWALL, L"POINTINGDOWNRIGHTWALL"},
    {TTP_BALLOONSTEM, TTBSS_POINTINGDOWNCENTERED, L"POINTINGDOWNCENTERED"},
    {TTP_BALLOONSTEM, TTBSS_POINTINGDOWNLEFTWALL, L"POINTINGDOWNLEFTWALL"},
    {TTP_WRENCH, 0, L"WRENCH"},
    {TTP_WRENCH, TTWS_NORMAL, L"NORMAL"},
    {TTP_WRENCH, TTWS_HOT, L"HOT"},
    {TTP_WRENCH, TTWS_PRESSED, L"PRESSED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classTrackbar[] =
{
    {TKP_TRACK, 0, L"TRACK"},
    {TKP_TRACK, TRS_NORMAL, L"NORMAL"},
    {TKP_TRACKVERT, 0, L"TRACKVERT"},
    {TKP_TRACKVERT, TRVS_NORMAL, L"NORMAL"},
    {TKP_THUMB, 0, L"THUMB"},
    {TKP_THUMB, TUS_NORMAL, L"NORMAL"},
    {TKP_THUMB, TUS_HOT, L"HOT"},
    {TKP_THUMB, TUS_PRESSED, L"PRESSED"},
    {TKP_THUMB, TUS_FOCUSED, L"FOCUSED"},
    {TKP_THUMB, TUS_DISABLED, L"DISABLED"},
    {TKP_THUMBBOTTOM, 0, L"THUMBBOTTOM"},
    {TKP_THUMBBOTTOM, TUBS_NORMAL, L"NORMAL"},
    {TKP_THUMBBOTTOM, TUBS_HOT, L"HOT"},
    {TKP_THUMBBOTTOM, TUBS_PRESSED, L"PRESSED"},
    {TKP_THUMBBOTTOM, TUBS_FOCUSED, L"FOCUSED"},
    {TKP_THUMBBOTTOM, TUBS_DISABLED, L"DISABLED"},
    {TKP_THUMBTOP, 0, L"THUMBTOP"},
    {TKP_THUMBTOP, TUTS_NORMAL, L"NORMAL"},
    {TKP_THUMBTOP, TUTS_HOT, L"HOT"},
    {TKP_THUMBTOP, TUTS_PRESSED, L"PRESSED"},
    {TKP_THUMBTOP, TUTS_FOCUSED, L"FOCUSED"},
    {TKP_THUMBTOP, TUTS_DISABLED, L"DISABLED"},
    {TKP_THUMBVERT, 0, L"THUMBVERT"},
    {TKP_THUMBVERT, TUVS_NORMAL, L"NORMAL"},
    {TKP_THUMBVERT, TUVS_HOT, L"HOT"},
    {TKP_THUMBVERT, TUVS_PRESSED, L"PRESSED"},
    {TKP_THUMBVERT, TUVS_FOCUSED, L"FOCUSED"},
    {TKP_THUMBVERT, TUVS_DISABLED, L"DISABLED"},
    {TKP_THUMBLEFT, 0, L"THUMBLEFT"},
    {TKP_THUMBLEFT, TUVLS_NORMAL, L"NORMAL"},
    {TKP_THUMBLEFT, TUVLS_HOT, L"HOT"},
    {TKP_THUMBLEFT, TUVLS_PRESSED, L"PRESSED"},
    {TKP_THUMBLEFT, TUVLS_FOCUSED, L"FOCUSED"},
    {TKP_THUMBLEFT, TUVLS_DISABLED, L"DISABLED"},
    {TKP_THUMBRIGHT, 0, L"THUMBRIGHT"},
    {TKP_THUMBRIGHT, TUVRS_NORMAL, L"NORMAL"},
    {TKP_THUMBRIGHT, TUVRS_HOT, L"HOT"},
    {TKP_THUMBRIGHT, TUVRS_PRESSED, L"PRESSED"},
    {TKP_THUMBRIGHT, TUVRS_FOCUSED, L"FOCUSED"},
    {TKP_THUMBRIGHT, TUVRS_DISABLED, L"DISABLED"},
    {TKP_TICS, 0, L"TICS"},
    {TKP_TICS, TSS_NORMAL, L"NORMAL"},
    {TKP_TICSVERT, 0, L"TICSVERT"},
    {TKP_TICSVERT, TSVS_NORMAL, L"NORMAL"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classTraynotify[] =
{
    {TNP_BACKGROUND, 0, L"BACKGROUND"},
    {TNP_ANIMBACKGROUND, 0, L"ANIMBACKGROUND"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classTreeview[] =
{
    {TVP_TREEITEM, 0, L"TREEITEM"},
    {TVP_TREEITEM, TREIS_NORMAL, L"NORMAL"},
    {TVP_TREEITEM, TREIS_HOT, L"HOT"},
    {TVP_TREEITEM, TREIS_SELECTED, L"SELECTED"},
    {TVP_TREEITEM, TREIS_DISABLED, L"DISABLED"},
    {TVP_TREEITEM, TREIS_SELECTEDNOTFOCUS, L"SELECTEDNOTFOCUS"},
    {TVP_TREEITEM, TREIS_HOTSELECTED, L"HOTSELECTED"},
    {TVP_GLYPH, 0, L"GLYPH"},
    {TVP_GLYPH, GLPS_CLOSED, L"CLOSED"},
    {TVP_GLYPH, GLPS_OPENED, L"OPENED"},
    {TVP_BRANCH, 0, L"BRANCH"},
    {TVP_HOTGLYPH, 0, L"HOTGLYPH"},
    {TVP_HOTGLYPH, HGLPS_CLOSED, L"CLOSED"},
    {TVP_HOTGLYPH, HGLPS_OPENED, L"OPENED"},
    {0, 0, L""},
};

static const struct MSSTYLES_CLASS_MAP classWindow[] =
{
    {WP_CAPTION, 0, L"CAPTION"},
    {WP_CAPTION, CS_ACTIVE, L"ACTIVE"},
    {WP_CAPTION, CS_INACTIVE, L"INACTIVE"},
    {WP_CAPTION, CS_DISABLED, L"DISABLED"},
    {WP_SMALLCAPTION, 0, L"SMALLCAPTION"},
    {WP_SMALLCAPTION, CS_ACTIVE, L"ACTIVE"},
    {WP_SMALLCAPTION, CS_INACTIVE, L"INACTIVE"},
    {WP_SMALLCAPTION, CS_DISABLED, L"DISABLED"},
    {WP_MINCAPTION, 0, L"MINCAPTION"},
    {WP_MINCAPTION, MNCS_ACTIVE, L"ACTIVE"},
    {WP_MINCAPTION, MNCS_INACTIVE, L"INACTIVE"},
    {WP_MINCAPTION, MNCS_DISABLED, L"DISABLED"},
    {WP_SMALLMINCAPTION, 0, L"SMALLMINCAPTION"},
    {WP_SMALLMINCAPTION, MNCS_ACTIVE, L"ACTIVE"},
    {WP_SMALLMINCAPTION, MNCS_INACTIVE, L"INACTIVE"},
    {WP_SMALLMINCAPTION, MNCS_DISABLED, L"DISABLED"},
    {WP_MAXCAPTION, 0, L"MAXCAPTION"},
    {WP_MAXCAPTION, MXCS_ACTIVE, L"ACTIVE"},
    {WP_MAXCAPTION, MXCS_INACTIVE, L"INACTIVE"},
    {WP_MAXCAPTION, MXCS_DISABLED, L"DISABLED"},
    {WP_SMALLMAXCAPTION, 0, L"SMALLMAXCAPTION"},
    {WP_SMALLMAXCAPTION, MXCS_ACTIVE, L"ACTIVE"},
    {WP_SMALLMAXCAPTION, MXCS_INACTIVE, L"INACTIVE"},
    {WP_SMALLMAXCAPTION, MXCS_DISABLED, L"DISABLED"},
    {WP_FRAMELEFT, 0, L"FRAMELEFT"},
    {WP_FRAMELEFT, FS_ACTIVE, L"ACTIVE"},
    {WP_FRAMELEFT, FS_INACTIVE, L"INACTIVE"},
    {WP_FRAMERIGHT, 0, L"FRAMERIGHT"},
    {WP_FRAMERIGHT, FS_ACTIVE, L"ACTIVE"},
    {WP_FRAMERIGHT, FS_INACTIVE, L"INACTIVE"},
    {WP_FRAMEBOTTOM, 0, L"FRAMEBOTTOM"},
    {WP_FRAMEBOTTOM, FS_ACTIVE, L"ACTIVE"},
    {WP_FRAMEBOTTOM, FS_INACTIVE, L"INACTIVE"},
    {WP_SMALLFRAMELEFT, 0, L"SMALLFRAMELEFT"},
    {WP_SMALLFRAMELEFT, FS_ACTIVE, L"ACTIVE"},
    {WP_SMALLFRAMELEFT, FS_INACTIVE, L"INACTIVE"},
    {WP_SMALLFRAMERIGHT, 0, L"SMALLFRAMERIGHT"},
    {WP_SMALLFRAMERIGHT, FS_ACTIVE, L"ACTIVE"},
    {WP_SMALLFRAMERIGHT, FS_INACTIVE, L"INACTIVE"},
    {WP_SMALLFRAMEBOTTOM, 0, L"SMALLFRAMEBOTTOM"},
    {WP_SMALLFRAMEBOTTOM, FS_ACTIVE, L"ACTIVE"},
    {WP_SMALLFRAMEBOTTOM, FS_INACTIVE, L"INACTIVE"},
    {WP_SYSBUTTON, 0, L"SYSBUTTON"},
    {WP_SYSBUTTON, SBS_NORMAL, L"NORMAL"},
    {WP_SYSBUTTON, SBS_HOT, L"HOT"},
    {WP_SYSBUTTON, SBS_PUSHED, L"PUSHED"},
    {WP_SYSBUTTON, SBS_DISABLED, L"DISABLED"},
    {WP_MDISYSBUTTON, 0, L"MDISYSBUTTON"},
    {WP_MDISYSBUTTON, SBS_NORMAL, L"NORMAL"},
    {WP_MDISYSBUTTON, SBS_HOT, L"HOT"},
    {WP_MDISYSBUTTON, SBS_PUSHED, L"PUSHED"},
    {WP_MDISYSBUTTON, SBS_DISABLED, L"DISABLED"},
    {WP_MINBUTTON, 0, L"MINBUTTON"},
    {WP_MINBUTTON, MINBS_NORMAL, L"NORMAL"},
    {WP_MINBUTTON, MINBS_HOT, L"HOT"},
    {WP_MINBUTTON, MINBS_PUSHED, L"PUSHED"},
    {WP_MINBUTTON, MINBS_DISABLED, L"DISABLED"},
    {WP_MDIMINBUTTON, 0, L"MDIMINBUTTON"},
    {WP_MDIMINBUTTON, MINBS_NORMAL, L"NORMAL"},
    {WP_MDIMINBUTTON, MINBS_HOT, L"HOT"},
    {WP_MDIMINBUTTON, MINBS_PUSHED, L"PUSHED"},
    {WP_MDIMINBUTTON, MINBS_DISABLED, L"DISABLED"},
    {WP_MAXBUTTON, 0, L"MAXBUTTON"},
    {WP_MAXBUTTON, MAXBS_NORMAL, L"NORMAL"},
    {WP_MAXBUTTON, MAXBS_HOT, L"HOT"},
    {WP_MAXBUTTON, MAXBS_PUSHED, L"PUSHED"},
    {WP_MAXBUTTON, MAXBS_DISABLED, L"DISABLED"},
    {WP_CLOSEBUTTON, 0, L"CLOSEBUTTON"},
    {WP_CLOSEBUTTON, CBS_NORMAL, L"NORMAL"},
    {WP_CLOSEBUTTON, CBS_HOT, L"HOT"},
    {WP_CLOSEBUTTON, CBS_PUSHED, L"PUSHED"},
    {WP_CLOSEBUTTON, CBS_DISABLED, L"DISABLED"},
    {WP_SMALLCLOSEBUTTON, 0, L"SMALLCLOSEBUTTON"},
    {WP_SMALLCLOSEBUTTON, CBS_NORMAL, L"NORMAL"},
    {WP_SMALLCLOSEBUTTON, CBS_HOT, L"HOT"},
    {WP_SMALLCLOSEBUTTON, CBS_PUSHED, L"PUSHED"},
    {WP_SMALLCLOSEBUTTON, CBS_DISABLED, L"DISABLED"},
    {WP_MDICLOSEBUTTON, 0, L"MDICLOSEBUTTON"},
    {WP_MDICLOSEBUTTON, CBS_NORMAL, L"NORMAL"},
    {WP_MDICLOSEBUTTON, CBS_HOT, L"HOT"},
    {WP_MDICLOSEBUTTON, CBS_PUSHED, L"PUSHED"},
    {WP_MDICLOSEBUTTON, CBS_DISABLED, L"DISABLED"},
    {WP_RESTOREBUTTON, 0, L"RESTOREBUTTON"},
    {WP_RESTOREBUTTON, RBS_NORMAL, L"NORMAL"},
    {WP_RESTOREBUTTON, RBS_HOT, L"HOT"},
    {WP_RESTOREBUTTON, RBS_PUSHED, L"PUSHED"},
    {WP_RESTOREBUTTON, RBS_DISABLED, L"DISABLED"},
    {WP_MDIRESTOREBUTTON, 0, L"MDIRESTOREBUTTON"},
    {WP_MDIRESTOREBUTTON, RBS_NORMAL, L"NORMAL"},
    {WP_MDIRESTOREBUTTON, RBS_HOT, L"HOT"},
    {WP_MDIRESTOREBUTTON, RBS_PUSHED, L"PUSHED"},
    {WP_MDIRESTOREBUTTON, RBS_DISABLED, L"DISABLED"},
    {WP_HELPBUTTON, 0, L"HELPBUTTON"},
    {WP_HELPBUTTON, HBS_NORMAL, L"NORMAL"},
    {WP_HELPBUTTON, HBS_HOT, L"HOT"},
    {WP_HELPBUTTON, HBS_PUSHED, L"PUSHED"},
    {WP_HELPBUTTON, HBS_DISABLED, L"DISABLED"},
    {WP_MDIHELPBUTTON, 0, L"MDIHELPBUTTON"},
    {WP_MDIHELPBUTTON, HBS_NORMAL, L"NORMAL"},
    {WP_MDIHELPBUTTON, HBS_HOT, L"HOT"},
    {WP_MDIHELPBUTTON, HBS_PUSHED, L"PUSHED"},
    {WP_MDIHELPBUTTON, HBS_DISABLED, L"DISABLED"},
    {WP_HORZSCROLL, 0, L"HORZSCROLL"},
    {WP_HORZSCROLL, HSS_NORMAL, L"NORMAL"},
    {WP_HORZSCROLL, HSS_HOT, L"HOT"},
    {WP_HORZSCROLL, HSS_PUSHED, L"PUSHED"},
    {WP_HORZSCROLL, HSS_DISABLED, L"DISABLED"},
    {WP_HORZTHUMB, 0, L"HORZTHUMB"},
    {WP_HORZTHUMB, HTS_NORMAL, L"NORMAL"},
    {WP_HORZTHUMB, HTS_HOT, L"HOT"},
    {WP_HORZTHUMB, HTS_PUSHED, L"PUSHED"},
    {WP_HORZTHUMB, HTS_DISABLED, L"DISABLED"},
    {WP_VERTSCROLL, 0, L"VERTSCROLL"},
    {WP_VERTSCROLL, VSS_NORMAL, L"NORMAL"},
    {WP_VERTSCROLL, VSS_HOT, L"HOT"},
    {WP_VERTSCROLL, VSS_PUSHED, L"PUSHED"},
    {WP_VERTSCROLL, VSS_DISABLED, L"DISABLED"},
    {WP_VERTTHUMB, 0, L"VERTTHUMB"},
    {WP_VERTTHUMB, VTS_NORMAL, L"NORMAL"},
    {WP_VERTTHUMB, VTS_HOT, L"HOT"},
    {WP_VERTTHUMB, VTS_PUSHED, L"PUSHED"},
    {WP_VERTTHUMB, VTS_DISABLED, L"DISABLED"},
    {WP_DIALOG, 0, L"DIALOG"},
    {WP_CAPTIONSIZINGTEMPLATE, 0, L"CAPTIONSIZINGTEMPLATE"},
    {WP_SMALLCAPTIONSIZINGTEMPLATE, 0, L"SMALLCAPTIONSIZINGTEMPLATE"},
    {WP_FRAMELEFTSIZINGTEMPLATE, 0, L"FRAMELEFTSIZINGTEMPLATE"},
    {WP_SMALLFRAMELEFTSIZINGTEMPLATE, 0, L"SMALLFRAMELEFTSIZINGTEMPLATE"},
    {WP_FRAMERIGHTSIZINGTEMPLATE, 0, L"FRAMERIGHTSIZINGTEMPLATE"},
    {WP_SMALLFRAMERIGHTSIZINGTEMPLATE, 0, L"SMALLFRAMERIGHTSIZINGTEMPLATE"},
    {WP_FRAMEBOTTOMSIZINGTEMPLATE, 0, L"FRAMEBOTTOMSIZINGTEMPLATE"},
    {WP_SMALLFRAMEBOTTOMSIZINGTEMPLATE, 0, L"SMALLFRAMEBOTTOMSIZINGTEMPLATE"},
    {WP_FRAME, 0, L"FRAME"},
    {WP_FRAME, FS_ACTIVE, L"ACTIVE"},
    {WP_FRAME, FS_INACTIVE, L"INACTIVE"},
    {WP_BORDER, 0, L"BORDER"},
    {0, 0, L""},
};

/* Map class names to part/state maps */
static const struct MSSTYLES_CLASS_NAME mapClass[] =
{
    {classButton, L"BUTTON"},
    {classClock, L"CLOCK"},
    {classCombobox, L"COMBOBOX"},
    {classEdit, L"EDIT"},
    {classExplorerbar, L"EXPLORERBAR"},
    {classHeader, L"HEADER"},
    {classListview, L"LISTVIEW"},
    {classMenu, L"MENU"},
    {classMenuband, L"MENUBAND"},
    {classNavigation, L"NAVIGATION"},
    {classPage, L"PAGE"},
    {classProgress, L"PROGRESS"},
    {classRebar, L"REBAR"},
    {classScrollbar, L"SCROLLBAR"},
    {classSpin, L"SPIN"},
    {classStartpanel, L"STARTPANEL"},
    {classStatus, L"STATUS"},
    {classTab, L"TAB"},
    {classTaskband, L"TASKBAND"},
    {classTaskbar, L"TASKBAR"},
    {classTaskdialog, L"TASKDIALOG"},
    {classToolbar, L"TOOLBAR"},
    {classTooltip, L"TOOLTIP"},
    {classTrackbar, L"TRACKBAR"},
    {classTraynotify, L"TRAYNOTIFY"},
    {classTreeview, L"TREEVIEW"},
    {classWindow, L"WINDOW"},
};

static BOOL MSSTYLES_LookupPartState(LPCWSTR pszClass, LPCWSTR pszPart, LPCWSTR pszState, int *iPartId, int *iStateId)
{
    unsigned int i;
    const struct MSSTYLES_CLASS_MAP *map;

    *iPartId = 0;
    *iStateId = 0;
    for(i=0; i<ARRAY_SIZE(mapClass); i++) {
        if(!lstrcmpiW(mapClass[i].pszClass, pszClass)) {
            map = mapClass[i].lpMap;
            if(pszPart) {
                do {
                    if(map->dwStateID == 0 && !lstrcmpiW(map->szName, pszPart)) {
                        *iPartId = map->dwPartID;
                        break;
                    }
                } while(*((++map)->szName));
            }
            if(pszState) {
                if(pszPart && *iPartId == 0) {
                    break;
                }
                do {
                    if(pszPart) {
                        if(map->dwPartID == *iPartId && !lstrcmpiW(map->szName, pszState)) {
                            *iStateId = map->dwStateID;
                            break;
                        }
                    }
                    else {
                        if(!lstrcmpiW(map->szName, pszState)) {
                            *iStateId = map->dwStateID;
                            break;
                        }
                    }
                } while(*((++map)->szName));
            }
            break;
        }
    }
    if(pszPart && *iPartId == 0) {
        return FALSE;
    }
    if(pszState && *iStateId == 0) {
        return FALSE;
    }
    return TRUE;
}

/**********************************************************************
 *      UXINI_eof
 *
 * Determines if we are at the end of the INI file
 */
static inline BOOL UXINI_eof(PUXINI_FILE uf)
{
    return uf->lpCurLoc >= uf->lpEnd;
}

/**********************************************************************
 *      UXINI_isspace
 *
 * Check if a character is a space character
 */
static inline BOOL UXINI_isspace(WCHAR c)
{
    if (isspace(c)) return TRUE;
    if (c=='\r') return TRUE;
    return FALSE;
}

/**********************************************************************
 *      UXINI_GetNextLine
 *
 * Get the next line in the INI file, non NULL terminated
 * removes whitespace at beginning and end of line, and removes comments
 */
static LPCWSTR UXINI_GetNextLine(PUXINI_FILE uf, DWORD *dwLen)
{
    LPCWSTR lpLineEnd;
    LPCWSTR lpLineStart;
    DWORD len;
    do
    {
        if (UXINI_eof(uf)) return NULL;
        /* Skip whitespace and empty lines */
        while (!UXINI_eof(uf) && (UXINI_isspace(*uf->lpCurLoc) || *uf->lpCurLoc == '\n')) uf->lpCurLoc++;
        lpLineStart = uf->lpCurLoc;
        lpLineEnd = uf->lpCurLoc;
        while (!UXINI_eof(uf) && *uf->lpCurLoc != '\n' && *uf->lpCurLoc != ';') lpLineEnd = ++uf->lpCurLoc;
        /* If comment was found, skip the rest of the line */
        if (*uf->lpCurLoc == ';')
            while (!UXINI_eof(uf) && *uf->lpCurLoc != '\n') uf->lpCurLoc++;
        len = (lpLineEnd - lpLineStart);
        if (*lpLineStart != ';' && len == 0)
            return NULL;
    } while (*lpLineStart == ';');
    /* Remove whitespace from end of line */
    while (UXINI_isspace(lpLineStart[len - 1])) len--;
    *dwLen = len;

    return lpLineStart;
}

static inline void UXINI_UnGetToLine(PUXINI_FILE uf, LPCWSTR lpLine)
{
    uf->lpCurLoc = lpLine;
}

/**********************************************************************
 *      UXINI_GetNextSection
 *
 * Locate the next section in the ini file, and return pointer to
 * section name, non NULL terminated. Use dwLen to determine length
 */
static LPCWSTR UXINI_GetNextSection(PUXINI_FILE uf, DWORD *dwLen)
{
    LPCWSTR lpLine;
    while ((lpLine = UXINI_GetNextLine(uf, dwLen)))
    {
        /* Assuming a ']' ending to the section name */
        if (lpLine[0] == '[')
        {
            lpLine++;
            *dwLen -= 2;
            break;
        }
    }
    return lpLine;
}

/**********************************************************************
 *      UXINI_GetNextValue
 *
 * Locate the next value in the current section
 */
static LPCWSTR UXINI_GetNextValue(PUXINI_FILE uf, DWORD *dwNameLen, LPCWSTR *lpValue, DWORD *dwValueLen)
{
    LPCWSTR lpLine;
    LPCWSTR lpLineEnd;
    LPCWSTR name = NULL;
    LPCWSTR value = NULL;
    DWORD vallen = 0;
    DWORD namelen = 0;
    DWORD dwLen;
    lpLine = UXINI_GetNextLine(uf, &dwLen);
    if (!lpLine)
        return NULL;
    if (lpLine[0] == '[')
    {
        UXINI_UnGetToLine(uf, lpLine);
        return NULL;
    }
    lpLineEnd = lpLine + dwLen;

    name = lpLine;
    while (namelen < dwLen && *lpLine != '=')
    {
        lpLine++;
        namelen++;
    }
    if (*lpLine != '=')
        return NULL;
    lpLine++;

    /* Remove whitespace from end of name */
    while (UXINI_isspace(name[namelen - 1])) namelen--;
    /* Remove whitespace from beginning of value */
    while (UXINI_isspace(*lpLine) && lpLine < lpLineEnd) lpLine++;
    value = lpLine;
    vallen = dwLen - (value - name);

    *dwNameLen = namelen;
    *dwValueLen = vallen;
    *lpValue = value;

    return name;
}

/**********************************************************************
 *      UXINI_FindValue
 *
 * Locate a value by name
 */
BOOL UXINI_FindValue(PUXINI_FILE uf, const WCHAR *section, const WCHAR *name, WCHAR *buffer, DWORD length)
{
    struct uxini_string key[2] = {{.buf = section, .len = -1}, {.buf = name, .len = -1}};
    struct wine_rb_entry *entry;
    struct uxini_value *value;

    if (!(entry = wine_rb_get(&uf->values, key))) return FALSE;
    value = WINE_RB_ENTRY_VALUE(entry, struct uxini_value, entry);
    lstrcpynW(buffer, value->value.buf, length);
    return TRUE;
}

static void uxini_dump_values(UXINI_FILE *file)
{
    const struct uxini_string *prev_section = NULL;
    struct uxini_value *value;

    TRACE("file %p\n", file);
    TRACE("  SysMetrics:\n");
    WINE_RB_FOR_EACH_ENTRY(value, &file->sys_metrics, struct uxini_value, entry)
        TRACE("    %s = %s\n", debugstr_w(value->name), debugstr_w(value->value));

    WINE_RB_FOR_EACH_ENTRY(value, &file->values, struct uxini_value, entry)
    {
        if (!prev_section || uxini_string_compare(prev_section, &value->section))
        {
            prev_section = &value->section;
            TRACE("  %s:\n", debugstr_wn(value->section.buf, value->section.len));
        }

        TRACE("    %s = %s\n", debugstr_wn(value->name.buf, value->name.len),
              debugstr_wn(value->value.buf, value->value.len));
    }
}

static void uxini_parse_values(UXINI_FILE *file)
{
    const WCHAR *section_buf;
    DWORD section_len;

    while ((section_buf = UXINI_GetNextSection(file, &section_len)))
    {
        WCHAR class_name[MAX_THEME_CLASS_NAME], app_name[MAX_THEME_APP_NAME];
        struct uxini_string section = {.buf = section_buf, .len = section_len};
        struct wine_rb_tree *values = &file->values;
        const WCHAR *name_buf, *value_buf;
        DWORD name_len, value_len;

        if (CompareStringOrdinal(section, -1, L"SysMetrics", -1, TRUE) == CSTR_EQUAL) values = &file->sys_metrics;
        else if (!MSSTYLES_ParseIniSectionName(section, section_len, app_name, class_name, &part_id, &state_id)) continue;
        is_global = CompareStringOrdinal(class_name, -1, L"globals", -1, TRUE) == CSTR_EQUAL;

        while ((name_buf = UXINI_GetNextValue(file, &name_len, &value_buf, &value_len)))
        {
            struct uxini_string value = {.buf = value_buf, .len = value_len};
            struct uxini_string name = {.buf = name_buf, .len = name_len};
            struct uxini_string key[2] = {section, value};
            struct uxini_value *entry;

            if (!(entry = heap_alloc(sizeof(*entry)))) return;
            entry->part_id = part_id;
            entry->state_id = state_id;
            entry->is_global = is_global;

            entry->section = section;
            entry->name = name;
            entry->value = value;

            if (!uxini_lookup_property(&entry->name, &entry->prop_type, &entry->prop_id))
            {
                WARN("Ignoring unknown property %s / %s\n", debugstr_wn(section.buf, section.len),
                     debugstr_wn(name.buf, name.len));
                heap_free(entry);
                continue;
            }

            if (wine_rb_put(values, key, &entry->entry)) heap_free(entry);
            {
                WARN("Ignoring duplicate property %s / %s\n", debugstr_wn(section.buf, section.len),
                     debugstr_wn(name.buf, name.len));
                heap_free(entry);
            }
        }
    }

    if (TRACE_ON(uxtheme)) uxini_dump_values(file);
}

/**********************************************************************
 *      UXINI_LoadINI
 *
 * Load a theme INI file out of resources from the specified
 * theme
 */
static PUXINI_FILE UXINI_LoadINI(HMODULE hTheme, LPCWSTR lpName)
{
    HRSRC hrsc;
    LPCWSTR lpThemesIni = NULL;
    PUXINI_FILE uf;
    DWORD dwIniSize;

    TRACE("Loading resource INI %s\n", debugstr_w(lpName));

    if ((hrsc = FindResourceW(hTheme, lpName, L"TEXTFILE")))
    {
        if (!(lpThemesIni = LoadResource(hTheme, hrsc)))
        {
            TRACE("%s resource not found\n", debugstr_w(lpName));
            return NULL;
        }
    }

    dwIniSize = SizeofResource(hTheme, hrsc) / sizeof(WCHAR);
    uf = heap_alloc(sizeof(*uf));

    wine_rb_init(&uf->sys_metrics, uxini_value_compare);
    wine_rb_init(&uf->values, uxini_value_compare);
    uf->lpIni = lpThemesIni;
    uf->lpCurLoc = lpThemesIni;
    uf->lpEnd = lpThemesIni + dwIniSize;
    uxini_parse_values(uf);

    uf->lpIni = lpThemesIni;
    uf->lpCurLoc = lpThemesIni;
    uf->lpEnd = lpThemesIni + dwIniSize;
    return uf;
}

/**********************************************************************
 *      UXINI_CloseINI
 *
 * Close an open theme INI file
 */
void UXINI_CloseINI(PUXINI_FILE uf)
{
    wine_rb_destroy(&uf->values, uxini_value_destroy, NULL);
    wine_rb_destroy(&uf->sys_metrics, uxini_value_destroy, NULL);
    heap_free(uf);
}

/**********************************************************************
 *      MSSTYLES_OpenThemeFile
 *
 * Load and validate a theme
 *
 * PARAMS
 *     lpThemeFile         Path to theme file to load
 *     pszColorName        Color name wanted, can be NULL
 *     pszSizeName         Size name wanted, can be NULL
 *
 * NOTES
 * If pszColorName or pszSizeName are NULL, the default color/size will be used.
 * If one/both are provided, they are validated against valid color/sizes and if
 * a match is not found, the function fails.
 */
HRESULT MSSTYLES_OpenThemeFile(LPCWSTR lpThemeFile, LPCWSTR pszColorName, LPCWSTR pszSizeName, PTHEME_FILE *tf)
{
    HMODULE hTheme;
    HRSRC hrsc;
    HRESULT hr = S_OK;

    WORD version;
    DWORD versize;
    LPWSTR pszColors;
    LPWSTR pszSelectedColor = NULL;
    LPWSTR pszSizes;
    LPWSTR pszSelectedSize = NULL;
    LPWSTR tmp;

    TRACE("Opening %s\n", debugstr_w(lpThemeFile));

    hTheme = LoadLibraryExW(lpThemeFile, NULL, LOAD_LIBRARY_AS_DATAFILE);

    /* Validate that this is really a theme */
    if(!hTheme) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto invalid_theme;
    }
    if(!(hrsc = FindResourceW(hTheme, MAKEINTRESOURCEW(1), L"PACKTHEM_VERSION"))) {
        TRACE("No version resource found\n");
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto invalid_theme;
    }
    if((versize = SizeofResource(hTheme, hrsc)) != 2)
    {
        TRACE("Version resource found, but wrong size: %ld\n", versize);
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto invalid_theme;
    }
    version = *(WORD*)LoadResource(hTheme, hrsc);
    if(version != MSSTYLES_VERSION)
    {
        TRACE("Version of theme file is unsupported: 0x%04x\n", version);
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto invalid_theme;
    }

    if(!(hrsc = FindResourceW(hTheme, MAKEINTRESOURCEW(1), L"COLORNAMES"))) {
        TRACE("Color names resource not found\n");
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto invalid_theme;
    }
    pszColors = LoadResource(hTheme, hrsc);

    if(!(hrsc = FindResourceW(hTheme, MAKEINTRESOURCEW(1), L"SIZENAMES"))) {
        TRACE("Size names resource not found\n");
        hr = HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
        goto invalid_theme;
    }
    pszSizes = LoadResource(hTheme, hrsc);

    /* Validate requested color against what's available from the theme */
    if(pszColorName) {
        tmp = pszColors;
        while(*tmp) {
            if(!lstrcmpiW(pszColorName, tmp)) {
                pszSelectedColor = tmp;
                break;
            }
            tmp += lstrlenW(tmp)+1;
        }
    }
    else
        pszSelectedColor = pszColors; /* Use the default color */

    /* Validate requested size against what's available from the theme */
    if(pszSizeName) {
        tmp = pszSizes;
        while(*tmp) {
            if(!lstrcmpiW(pszSizeName, tmp)) {
                pszSelectedSize = tmp;
                break;
            }
            tmp += lstrlenW(tmp)+1;
        }
    }
    else
        pszSelectedSize = pszSizes; /* Use the default size */

    if(!pszSelectedColor || !pszSelectedSize) {
        TRACE("Requested color/size (%s/%s) not found in theme\n",
              debugstr_w(pszColorName), debugstr_w(pszSizeName));
        hr = E_PROP_ID_UNSUPPORTED;
        goto invalid_theme;
    }

    *tf = heap_alloc_zero(sizeof(THEME_FILE));
    (*tf)->hTheme = hTheme;
    
    GetFullPathNameW(lpThemeFile, MAX_PATH, (*tf)->szThemeFile, NULL);
    
    (*tf)->pszAvailColors = pszColors;
    (*tf)->pszAvailSizes = pszSizes;
    (*tf)->pszSelectedColor = pszSelectedColor;
    (*tf)->pszSelectedSize = pszSelectedSize;
    (*tf)->refcount = 1;
    return S_OK;

invalid_theme:
    *tf = NULL;
    if(hTheme) FreeLibrary(hTheme);
    return hr;
}

/***********************************************************************
 *      MSSTYLES_CloseThemeFile
 *
 * Close theme file and free resources
 */
void MSSTYLES_CloseThemeFile(PTHEME_FILE tf)
{
    LONG refcount;

    if(tf) {
        refcount = InterlockedDecrement(&tf->refcount);
        if (!refcount)
        {
            if(tf->hTheme) FreeLibrary(tf->hTheme);
            if(tf->classes) {
                while(tf->classes) {
                    PTHEME_CLASS pcls = tf->classes;
                    tf->classes = pcls->next;
                    while(pcls->partstate) {
                        PTHEME_PARTSTATE ps = pcls->partstate;

                        while(ps->properties) {
                            PTHEME_PROPERTY prop = ps->properties;
                            ps->properties = prop->next;
                            heap_free(prop);
                        }

                        pcls->partstate = ps->next;
                        heap_free(ps);
                    }
                    pcls->signature = 0;
                    heap_free(pcls);
                }
            }
            while (tf->images)
            {
                PTHEME_IMAGE img = tf->images;
                tf->images = img->next;
                DeleteObject (img->image);
                heap_free(img);
            }
            heap_free(tf);
        }
    }
}

/***********************************************************************
 *      MSSTYLES_SetActiveTheme
 *
 * Set the current active theme
 */
HRESULT MSSTYLES_SetActiveTheme(PTHEME_FILE tf, BOOL setMetrics)
{
    if(tfActiveTheme)
        MSSTYLES_CloseThemeFile(tfActiveTheme);
    tfActiveTheme = tf;
    if (tfActiveTheme)
    {
        InterlockedIncrement(&tfActiveTheme->refcount);
	if(!tfActiveTheme->classes)
	    MSSTYLES_ParseThemeIni(tfActiveTheme, setMetrics);
    }
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_GetThemeIni
 *
 * Retrieves themes.ini from a theme
 */
PUXINI_FILE MSSTYLES_GetThemeIni(PTHEME_FILE tf)
{
    return UXINI_LoadINI(tf->hTheme, L"themes_ini");
}

/***********************************************************************
 *      MSSTYLES_GetThemeDPI
 *
 * Retrieves the DPI from a theme handle when it was opened
 */
UINT MSSTYLES_GetThemeDPI(PTHEME_CLASS tc)
{
    return tc->dpi;
}

/***********************************************************************
 *      MSSTYLES_GetActiveThemeIni
 *
 * Retrieve the ini file for the selected color/style
 */
static PUXINI_FILE MSSTYLES_GetActiveThemeIni(PTHEME_FILE tf)
{
    DWORD dwColorCount = 0;
    DWORD dwSizeCount = 0;
    DWORD dwColorNum = 0;
    DWORD dwSizeNum = 0;
    DWORD i;
    DWORD dwResourceIndex;
    LPWSTR tmp;
    HRSRC hrsc;

    /* Count the number of available colors & styles, and determine the index number
       of the color/style we are interested in
    */
    tmp = tf->pszAvailColors;
    while(*tmp) {
        if(!lstrcmpiW(tf->pszSelectedColor, tmp))
            dwColorNum = dwColorCount;
        tmp += lstrlenW(tmp)+1;
        dwColorCount++;
    }
    tmp = tf->pszAvailSizes;
    while(*tmp) {
        if(!lstrcmpiW(tf->pszSelectedSize, tmp))
            dwSizeNum = dwSizeCount;
        tmp += lstrlenW(tmp)+1;
        dwSizeCount++;
    }

    if(!(hrsc = FindResourceW(tf->hTheme, MAKEINTRESOURCEW(1), L"FILERESNAMES"))) {
        TRACE("FILERESNAMES map not found\n");
        return NULL;
    }
    tmp = LoadResource(tf->hTheme, hrsc);
    dwResourceIndex = (dwSizeCount * dwColorNum) + dwSizeNum;
    for(i=0; i < dwResourceIndex; i++) {
        tmp += lstrlenW(tmp)+1;
    }
    return UXINI_LoadINI(tf->hTheme, tmp);
}


/***********************************************************************
 *      MSSTYLES_ParseIniSectionName
 *
 * Parse an ini section name into its component parts
 * Valid formats are:
 * [classname]
 * [classname(state)]
 * [classname.part]
 * [classname.part(state)]
 * [application::classname]
 * [application::classname(state)]
 * [application::classname.part]
 * [application::classname.part(state)]
 *
 * PARAMS
 *     lpSection           Section name
 *     dwLen               Length of section name
 *     szAppName           Location to store application name
 *     szClassName         Location to store class name
 *     iPartId             Location to store part id
 *     iStateId            Location to store state id
 */
static BOOL MSSTYLES_ParseIniSectionName(LPCWSTR lpSection, DWORD dwLen, LPWSTR szAppName, LPWSTR szClassName, int *iPartId, int *iStateId)
{
    WCHAR sec[255];
    WCHAR part[60] = {'\0'};
    WCHAR state[60] = {'\0'};
    LPWSTR tmp;
    LPWSTR comp;
    lstrcpynW(sec, lpSection, min(dwLen+1, ARRAY_SIZE(sec)));

    *szAppName = 0;
    *szClassName = 0;
    *iPartId = 0;
    *iStateId = 0;
    comp = sec;
    /* Get the application name */
    tmp = wcschr(comp, ':');
    if(tmp) {
        *tmp++ = 0;
        tmp++;
        lstrcpynW(szAppName, comp, MAX_THEME_APP_NAME);
        comp = tmp;
    }

    tmp = wcschr(comp, '.');
    if(tmp) {
        *tmp++ = 0;
        lstrcpynW(szClassName, comp, MAX_THEME_CLASS_NAME);
        comp = tmp;
        /* now get the part & state */
        tmp = wcschr(comp, '(');
        if(tmp) {
            *tmp++ = 0;
            lstrcpynW(part, comp, ARRAY_SIZE(part));
            comp = tmp;
            /* now get the state */
            tmp = wcschr(comp, ')');
            if (!tmp)
                return FALSE;
            *tmp = 0;
            lstrcpynW(state, comp, ARRAY_SIZE(state));
        }
        else {
            lstrcpynW(part, comp, ARRAY_SIZE(part));
        }
    }
    else {
        tmp = wcschr(comp, '(');
        if(tmp) {
            *tmp++ = 0;
            lstrcpynW(szClassName, comp, MAX_THEME_CLASS_NAME);
            comp = tmp;
            /* now get the state */
            tmp = wcschr(comp, ')');
            if (!tmp)
                return FALSE;
            *tmp = 0;
            lstrcpynW(state, comp, ARRAY_SIZE(state));
        }
        else {
            lstrcpynW(szClassName, comp, MAX_THEME_CLASS_NAME);
        }
    }
    if(!*szClassName) return FALSE;
    return MSSTYLES_LookupPartState(szClassName, part[0]?part:NULL, state[0]?state:NULL, iPartId, iStateId);
}

/***********************************************************************
 *      MSSTYLES_FindClass
 *
 * Find a class
 *
 * PARAMS
 *     tf                  Theme file
 *     pszAppName          App name to find
 *     pszClassName        Class name to find
 *
 * RETURNS
 *  The class found, or NULL
 */
static PTHEME_CLASS MSSTYLES_FindClass(PTHEME_FILE tf, LPCWSTR pszAppName, LPCWSTR pszClassName)
{
    PTHEME_CLASS cur = tf->classes;
    while(cur) {
        if(!pszAppName) {
            if(!*cur->szAppName && !lstrcmpiW(pszClassName, cur->szClassName))
                return cur;
        }
        else {
            if(!lstrcmpiW(pszAppName, cur->szAppName) && !lstrcmpiW(pszClassName, cur->szClassName))
                return cur;
        }
        cur = cur->next;
    }
    return NULL;
}

/***********************************************************************
 *      MSSTYLES_AddClass
 *
 * Add a class to a theme file
 *
 * PARAMS
 *     tf                  Theme file
 *     pszAppName          App name to add
 *     pszClassName        Class name to add
 *
 * RETURNS
 *  The class added, or a class previously added with the same name
 */
static PTHEME_CLASS MSSTYLES_AddClass(PTHEME_FILE tf, LPCWSTR pszAppName, LPCWSTR pszClassName)
{
    PTHEME_CLASS cur = MSSTYLES_FindClass(tf, pszAppName, pszClassName);
    if(cur) return cur;

    cur = heap_alloc(sizeof(*cur));
    cur->signature = THEME_CLASS_SIGNATURE;
    cur->refcount = 0;
    cur->hTheme = tf->hTheme;
    lstrcpyW(cur->szAppName, pszAppName);
    lstrcpyW(cur->szClassName, pszClassName);
    cur->next = tf->classes;
    cur->partstate = NULL;
    cur->overrides = NULL;
    tf->classes = cur;
    return cur;
}

/***********************************************************************
 *      MSSTYLES_FindPart
 *
 * Find a part
 *
 * PARAMS
 *     tc                  Class to search
 *     iPartId             Part ID to find
 *
 * RETURNS
 *  The part found, or NULL
 */
PTHEME_PARTSTATE MSSTYLES_FindPart(PTHEME_CLASS tc, int iPartId)
{
    PTHEME_PARTSTATE cur = tc->partstate;

    while (cur)
    {
        if (cur->iPartId == iPartId)
            return cur;

        cur = cur->next;
    }

    if (tc->overrides)
        return MSSTYLES_FindPart(tc->overrides, iPartId);

    return NULL;
}

/***********************************************************************
 *      MSSTYLES_FindPartState
 *
 * Find a part/state
 *
 * PARAMS
 *     tc                  Class to search
 *     iPartId             Part ID to find
 *     iStateId            State ID to find
 *     tcNext              Receives the next class in the override chain
 *
 * RETURNS
 *  The part/state found, or NULL
 */
static PTHEME_PARTSTATE MSSTYLES_FindPartState(PTHEME_CLASS tc, int iPartId, int iStateId, PTHEME_CLASS *tcNext)
{
    PTHEME_PARTSTATE cur = tc->partstate;
    while(cur) {
        if(cur->iPartId == iPartId && cur->iStateId == iStateId) {
            if(tcNext) *tcNext = tc->overrides;
            return cur;
        }
        cur = cur->next;
    }
    if(tc->overrides) return MSSTYLES_FindPartState(tc->overrides, iPartId, iStateId, tcNext);
    return NULL;
}

/***********************************************************************
 *      MSSTYLES_AddPartState
 *
 * Add a part/state to a class
 *
 * PARAMS
 *     tc                  Theme class
 *     iPartId             Part ID to add
 *     iStateId            State ID to add
 *
 * RETURNS
 *  The part/state added, or a part/state previously added with the same IDs
 */
static PTHEME_PARTSTATE MSSTYLES_AddPartState(PTHEME_CLASS tc, int iPartId, int iStateId)
{
    PTHEME_PARTSTATE cur = MSSTYLES_FindPartState(tc, iPartId, iStateId, NULL);
    if(cur) return cur;

    cur = heap_alloc(sizeof(*cur));
    cur->iPartId = iPartId;
    cur->iStateId = iStateId;
    cur->properties = NULL;
    cur->next = tc->partstate;
    tc->partstate = cur;
    return cur;
}

/***********************************************************************
 *      MSSTYLES_LFindProperty
 *
 * Find a property within a property list
 *
 * PARAMS
 *     tp                  property list to scan
 *     iPropertyPrimitive  Type of value expected
 *     iPropertyId         ID of the required value
 *
 * RETURNS
 *  The property found, or NULL
 */
static PTHEME_PROPERTY MSSTYLES_LFindProperty(PTHEME_PROPERTY tp, int iPropertyPrimitive, int iPropertyId)
{
    PTHEME_PROPERTY cur = tp;
    while(cur) {
        if(cur->iPropertyId == iPropertyId) {
            if(cur->iPrimitiveType == iPropertyPrimitive) {
                return cur;
            }
            else {
                if(!iPropertyPrimitive)
                    return cur;
                return NULL;
            }
        }
        cur = cur->next;
    }
    return NULL;
}

/***********************************************************************
 *      MSSTYLES_PSFindProperty
 *
 * Find a value within a part/state
 *
 * PARAMS
 *     ps                  Part/state to search
 *     iPropertyPrimitive  Type of value expected
 *     iPropertyId         ID of the required value
 *
 * RETURNS
 *  The property found, or NULL
 */
static inline PTHEME_PROPERTY MSSTYLES_PSFindProperty(PTHEME_PARTSTATE ps, int iPropertyPrimitive, int iPropertyId)
{
    return MSSTYLES_LFindProperty(ps->properties, iPropertyPrimitive, iPropertyId);
}

/***********************************************************************
 *      MSSTYLES_FFindMetric
 *
 * Find a metric property for a theme file
 *
 * PARAMS
 *     tf                  Theme file
 *     iPropertyPrimitive  Type of value expected
 *     iPropertyId         ID of the required value
 *
 * RETURNS
 *  The property found, or NULL
 */
static inline PTHEME_PROPERTY MSSTYLES_FFindMetric(PTHEME_FILE tf, int iPropertyPrimitive, int iPropertyId)
{
    return MSSTYLES_LFindProperty(tf->metrics, iPropertyPrimitive, iPropertyId);
}

/***********************************************************************
 *      MSSTYLES_FindMetric
 *
 * Find a metric property for the current installed theme
 *
 * PARAMS
 *     tf                  Theme file
 *     iPropertyPrimitive  Type of value expected
 *     iPropertyId         ID of the required value
 *
 * RETURNS
 *  The property found, or NULL
 */
PTHEME_PROPERTY MSSTYLES_FindMetric(int iPropertyPrimitive, int iPropertyId)
{
    if(!tfActiveTheme) return NULL;
    return MSSTYLES_FFindMetric(tfActiveTheme, iPropertyPrimitive, iPropertyId);
}

/***********************************************************************
 *      MSSTYLES_AddProperty
 *
 * Add a property to a part/state
 *
 * PARAMS
 *     ps                  Part/state
 *     iPropertyPrimitive  Primitive type of the property
 *     iPropertyId         ID of the property
 *     lpValue             Raw value (non-NULL terminated)
 *     dwValueLen          Length of the value
 *
 * RETURNS
 *  The property added, or a property previously added with the same IDs
 */
static PTHEME_PROPERTY MSSTYLES_AddProperty(PTHEME_PARTSTATE ps, int iPropertyPrimitive, int iPropertyId, LPCWSTR lpValue, DWORD dwValueLen, BOOL isGlobal)
{
    PTHEME_PROPERTY cur = MSSTYLES_PSFindProperty(ps, iPropertyPrimitive, iPropertyId);
    /* Should duplicate properties overwrite the original, or be ignored? */
    if(cur) return cur;

    cur = heap_alloc(sizeof(*cur));
    cur->iPrimitiveType = iPropertyPrimitive;
    cur->iPropertyId = iPropertyId;
    cur->lpValue = lpValue;
    cur->dwValueLen = dwValueLen;

    if(ps->iStateId)
        cur->origin = PO_STATE;
    else if(ps->iPartId)
        cur->origin = PO_PART;
    else if(isGlobal)
        cur->origin = PO_GLOBAL;
    else
        cur->origin = PO_CLASS;

    cur->next = ps->properties;
    ps->properties = cur;
    return cur;
}

/***********************************************************************
 *      MSSTYLES_AddMetric
 *
 * Add a property to a part/state
 *
 * PARAMS
 *     tf                  Theme file
 *     iPropertyPrimitive  Primitive type of the property
 *     iPropertyId         ID of the property
 *     lpValue             Raw value (non-NULL terminated)
 *     dwValueLen          Length of the value
 *
 * RETURNS
 *  The property added, or a property previously added with the same IDs
 */
static PTHEME_PROPERTY MSSTYLES_AddMetric(PTHEME_FILE tf, int iPropertyPrimitive, int iPropertyId, LPCWSTR lpValue, DWORD dwValueLen)
{
    PTHEME_PROPERTY cur = MSSTYLES_FFindMetric(tf, iPropertyPrimitive, iPropertyId);
    /* Should duplicate properties overwrite the original, or be ignored? */
    if(cur) return cur;

    cur = heap_alloc(sizeof(*cur));
    cur->iPrimitiveType = iPropertyPrimitive;
    cur->iPropertyId = iPropertyId;
    cur->lpValue = lpValue;
    cur->dwValueLen = dwValueLen;

    cur->origin = PO_GLOBAL;

    cur->next = tf->metrics;
    tf->metrics = cur;
    return cur;
}

/* Color-related state for theme ini parsing */
struct PARSECOLORSTATE
{
    int colorCount;
    int colorElements[TMT_LASTCOLOR-TMT_FIRSTCOLOR+1];
    COLORREF colorRgb[TMT_LASTCOLOR-TMT_FIRSTCOLOR+1];
    int captionColors;
};

static inline void parse_init_color (struct PARSECOLORSTATE* state)
{
    memset (state, 0, sizeof (*state));
}

static BOOL parse_handle_color_property (struct PARSECOLORSTATE* state, 
                                         int iPropertyId, LPCWSTR lpValue,
                                         DWORD dwValueLen)
{
    int r,g,b;
    LPCWSTR lpValueEnd = lpValue + dwValueLen;
    if(MSSTYLES_GetNextInteger(lpValue, lpValueEnd, &lpValue, &r) &&
    MSSTYLES_GetNextInteger(lpValue, lpValueEnd, &lpValue, &g) &&
    MSSTYLES_GetNextInteger(lpValue, lpValueEnd, &lpValue, &b)) {
	state->colorElements[state->colorCount] = iPropertyId - TMT_FIRSTCOLOR;
	state->colorRgb[state->colorCount++] = RGB(r,g,b);
	switch (iPropertyId)
	{
	  case TMT_ACTIVECAPTION: 
	    state->captionColors |= 0x1; 
	    break;
	  case TMT_INACTIVECAPTION: 
	    state->captionColors |= 0x2; 
	    break;
	  case TMT_GRADIENTACTIVECAPTION: 
	    state->captionColors |= 0x4; 
	    break;
	  case TMT_GRADIENTINACTIVECAPTION: 
	    state->captionColors |= 0x8; 
	    break;
	}
	return TRUE;
    }
    else {
	return FALSE;
    }
}

static void parse_apply_color (struct PARSECOLORSTATE* state)
{
    if (state->colorCount > 0)
	SetSysColors(state->colorCount, state->colorElements, state->colorRgb);
    if (state->captionColors == 0xf)
	SystemParametersInfoW (SPI_SETGRADIENTCAPTIONS, 0, (PVOID)TRUE, 0);
}

/* Non-client-metrics-related state for theme ini parsing */
struct PARSENONCLIENTSTATE
{
    NONCLIENTMETRICSW metrics;
    BOOL metricsDirty;
    LOGFONTW iconTitleFont;
};

static inline void parse_init_nonclient (struct PARSENONCLIENTSTATE* state)
{
    DPI_AWARENESS_CONTEXT old_context;

    old_context = SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_UNAWARE);

    memset (state, 0, sizeof (*state));
    state->metrics.cbSize = sizeof (NONCLIENTMETRICSW);
    SystemParametersInfoW (SPI_GETNONCLIENTMETRICS, sizeof (NONCLIENTMETRICSW),
        &state->metrics, 0);
    SystemParametersInfoW (SPI_GETICONTITLELOGFONT, sizeof (LOGFONTW),
        &state->iconTitleFont, 0);

    SetThreadDpiAwarenessContext(old_context);
}

static BOOL parse_handle_nonclient_font (struct PARSENONCLIENTSTATE* state, 
                                         int iPropertyId, LPCWSTR lpValue,
                                         DWORD dwValueLen)
{
    LOGFONTW font;
    
    memset (&font, 0, sizeof (font));
    if (SUCCEEDED (MSSTYLES_GetFont (lpValue, lpValue + dwValueLen, &lpValue,
        &font)))
    {
        switch (iPropertyId)
        {
	  case TMT_CAPTIONFONT:
	      state->metrics.lfCaptionFont = font;
	      state->metricsDirty = TRUE;
	      break;
	  case TMT_SMALLCAPTIONFONT:
	      state->metrics.lfSmCaptionFont = font;
	      state->metricsDirty = TRUE;
	      break;
	  case TMT_MENUFONT:
	      state->metrics.lfMenuFont = font;
	      state->metricsDirty = TRUE;
	      break;
	  case TMT_STATUSFONT:
	      state->metrics.lfStatusFont = font;
	      state->metricsDirty = TRUE;
	      break;
	  case TMT_MSGBOXFONT:
	      state->metrics.lfMessageFont = font;
	      state->metricsDirty = TRUE;
	      break;
	  case TMT_ICONTITLEFONT:
	      state->iconTitleFont = font;
	      state->metricsDirty = TRUE;
	      break;
        }
        return TRUE;
    }
    else
        return FALSE;
}

static BOOL parse_handle_nonclient_size (struct PARSENONCLIENTSTATE* state, 
                                         int iPropertyId, LPCWSTR lpValue,
                                         DWORD dwValueLen)
{
    int size;
    LPCWSTR lpValueEnd = lpValue + dwValueLen;
    if(MSSTYLES_GetNextInteger(lpValue, lpValueEnd, &lpValue, &size)) {
        switch (iPropertyId)
        {
            case TMT_SIZINGBORDERWIDTH:
                state->metrics.iBorderWidth = size;
                state->metricsDirty = TRUE;
                break;
            case TMT_SCROLLBARWIDTH:
                state->metrics.iScrollWidth = size;
                state->metricsDirty = TRUE;
                break;
            case TMT_SCROLLBARHEIGHT:
                state->metrics.iScrollHeight = size;
                state->metricsDirty = TRUE;
                break;
            case TMT_CAPTIONBARWIDTH:
                state->metrics.iCaptionWidth = size;
                state->metricsDirty = TRUE;
                break;
            case TMT_CAPTIONBARHEIGHT:
                state->metrics.iCaptionHeight = size;
                state->metricsDirty = TRUE;
                break;
            case TMT_SMCAPTIONBARWIDTH:
                state->metrics.iSmCaptionWidth = size;
                state->metricsDirty = TRUE;
                break;
            case TMT_SMCAPTIONBARHEIGHT:
                state->metrics.iSmCaptionHeight = size;
                state->metricsDirty = TRUE;
                break;
            case TMT_MENUBARWIDTH:
                state->metrics.iMenuWidth = size;
                state->metricsDirty = TRUE;
                break;
            case TMT_MENUBARHEIGHT:
                state->metrics.iMenuHeight = size;
                state->metricsDirty = TRUE;
                break;
        }
        return TRUE;
    }
    else
        return FALSE;
}

static void parse_apply_nonclient (struct PARSENONCLIENTSTATE* state)
{
    DPI_AWARENESS_CONTEXT old_context;

    if (state->metricsDirty)
    {
        old_context = SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT_UNAWARE);
        SystemParametersInfoW (SPI_SETNONCLIENTMETRICS, sizeof (state->metrics),
            &state->metrics, 0);
        SystemParametersInfoW (SPI_SETICONTITLELOGFONT, sizeof (state->iconTitleFont),
            &state->iconTitleFont, 0);
        SetThreadDpiAwarenessContext(old_context);
    }
}

/***********************************************************************
 *      MSSTYLES_ParseThemeIni
 *
 * Parse the theme ini for the selected color/style
 *
 * PARAMS
 *     tf                  Theme to parse
 */
static void MSSTYLES_ParseThemeIni(PTHEME_FILE tf, BOOL setMetrics)
{
    struct PARSENONCLIENTSTATE nonClientState;
    struct PARSECOLORSTATE colorState;
    struct uxini_value *value;
    PTHEME_CLASS cls;
    PTHEME_CLASS globals;
    PTHEME_PARTSTATE ps;
    PUXINI_FILE ini;
    WCHAR szAppName[MAX_THEME_APP_NAME];
    WCHAR szClassName[MAX_THEME_CLASS_NAME];
    WCHAR szPropertyName[MAX_THEME_VALUE_NAME];
    int iPartId;
    int iStateId;
    int iPropertyPrimitive;
    int iPropertyId;
    DWORD dwLen;
    LPCWSTR lpName;
    DWORD dwValueLen;
    LPCWSTR lpValue;

    ini = MSSTYLES_GetActiveThemeIni(tf);

    parse_init_color(&colorState);
    parse_init_nonclient(&nonClientState);

    WINE_RB_FOR_EACH_ENTRY(value, &ini->sys_metrics, struct uxini_value, entry)
    {
        DWORD dwValueLen = wcslen(value->value);
        const WCHAR *lpValue = value->value;
        int iPropertyId = value->prop_id;

        if (iPropertyId >= TMT_FIRSTCOLOR && iPropertyId <= TMT_LASTCOLOR)
        {
            if (!parse_handle_color_property(&colorState, iPropertyId, lpValue, dwValueLen))
                FIXME("Invalid color value for %s\n", debugstr_w(szPropertyName));
        }
        else if (setMetrics && iPropertyId == TMT_FLATMENUS)
        {
            BOOL flatMenus = lpValue[0] == 'T' || lpValue[0] == 't';
            SystemParametersInfoW(SPI_SETFLATMENU, 0, (PVOID)(INT_PTR)flatMenus, 0);
        }
        else if (iPropertyId >= TMT_FIRSTFONT && iPropertyId <= TMT_LASTFONT)
        {
            if (!parse_handle_nonclient_font(&nonClientState, iPropertyId, lpValue, dwValueLen))
                FIXME("Invalid font value for %s\n", debugstr_w(szPropertyName));
        }
        else if (iPropertyId >= TMT_FIRSTSIZE && iPropertyId <= TMT_LASTSIZE)
        {
            if (!parse_handle_nonclient_size(&nonClientState, iPropertyId, lpValue, dwValueLen))
                FIXME("Invalid size value for %s\n",  debugstr_w(szPropertyName));
        }

        /* Catch all metrics, including colors */
        MSSTYLES_AddMetric(tf, value->prop_type, iPropertyId, lpValue, dwValueLen);
    }

    if (setMetrics)
    {
        parse_apply_color(&colorState);
        parse_apply_nonclient(&nonClientState);
    }

    while((lpName=UXINI_GetNextSection(ini, &dwLen))) {
        if(CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpName, dwLen, L"SysMetrics", -1) == CSTR_EQUAL)
            continue;
        if(MSSTYLES_ParseIniSectionName(lpName, dwLen, szAppName, szClassName, &iPartId, &iStateId)) {
            BOOL isGlobal = FALSE;
            if(!lstrcmpiW(szClassName, L"globals")) {
                isGlobal = TRUE;
            }
            cls = MSSTYLES_AddClass(tf, szAppName, szClassName);
            ps = MSSTYLES_AddPartState(cls, iPartId, iStateId);

            while((lpName=UXINI_GetNextValue(ini, &dwLen, &lpValue, &dwValueLen))) {
                lstrcpynW(szPropertyName, lpName, min(dwLen+1, ARRAY_SIZE(szPropertyName)));
                if(MSSTYLES_LookupProperty(szPropertyName, &iPropertyPrimitive, &iPropertyId)) {
                    MSSTYLES_AddProperty(ps, iPropertyPrimitive, iPropertyId, lpValue, dwValueLen, isGlobal);
                }
                else {
                    TRACE("Unknown property %s\n", debugstr_w(szPropertyName));
                }
            }
        }
    }

    /* App/Class combos override values defined by the base class, map these overrides */
    globals = MSSTYLES_FindClass(tf, NULL, L"globals");
    cls = tf->classes;
    while(cls) {
        if(*cls->szAppName) {
            cls->overrides = MSSTYLES_FindClass(tf, NULL, cls->szClassName);
            if(!cls->overrides) {
                TRACE("No overrides found for app %s class %s\n", debugstr_w(cls->szAppName), debugstr_w(cls->szClassName));
            }
            else {
                cls->overrides = globals;
            }
        }
        else {
            /* Everything overrides globals..except globals */
            if(cls != globals) cls->overrides = globals;
        }
        cls = cls->next;
    }
    UXINI_CloseINI(ini);

    if(!tf->classes) {
        ERR("Failed to parse theme ini\n");
    }
}

/***********************************************************************
 *      MSSTYLES_OpenThemeClass
 *
 * Open a theme class, uses the current active theme
 *
 * PARAMS
 *     pszAppName          Application name, for theme styles specific
 *                         to a particular application
 *     pszClassList        List of requested classes, semicolon delimited
 *     dpi                 DPI for theme parts
 */
PTHEME_CLASS MSSTYLES_OpenThemeClass(LPCWSTR pszAppName, LPCWSTR pszClassList, UINT dpi)
{
    PTHEME_CLASS cls = NULL;
    WCHAR szClassName[MAX_THEME_CLASS_NAME];
    LPCWSTR start;
    LPCWSTR end;
    DWORD len;

    if(!tfActiveTheme) {
        TRACE("there is no active theme\n");
        return NULL;
    }
    if(!tfActiveTheme->classes) {
	return NULL;
    }

    start = pszClassList;
    while((end = wcschr(start, ';'))) {
        len = end-start;
        lstrcpynW(szClassName, start, min(len+1, ARRAY_SIZE(szClassName)));
        start = end+1;
        cls = MSSTYLES_FindClass(tfActiveTheme, pszAppName, szClassName);
        if(cls) break;
    }
    if(!cls && *start) {
        lstrcpynW(szClassName, start, ARRAY_SIZE(szClassName));
        cls = MSSTYLES_FindClass(tfActiveTheme, pszAppName, szClassName);
    }
    if(cls) {
        TRACE("Opened app %s, class %s from list %s\n", debugstr_w(cls->szAppName), debugstr_w(cls->szClassName), debugstr_w(pszClassList));
	cls->tf = tfActiveTheme;
        InterlockedIncrement(&cls->tf->refcount);
        InterlockedIncrement(&cls->refcount);
        cls->dpi = dpi;
    }
    return cls;
}

/***********************************************************************
 *      MSSTYLES_CloseThemeClass
 *
 * Close a theme class
 *
 * PARAMS
 *     tc                  Theme class to close
 *
 * NOTES
 *  The MSSTYLES_CloseThemeFile decreases the refcount of the owning
 *  theme file and cleans it up, if needed.
 */
HRESULT MSSTYLES_CloseThemeClass(PTHEME_CLASS tc)
{
    LONG refcount;

    __TRY
    {
        if (tc->signature != THEME_CLASS_SIGNATURE)
            tc = NULL;
    }
    __EXCEPT_PAGE_FAULT
    {
        tc = NULL;
    }
    __ENDTRY

    if (!tc)
    {
        WARN("Invalid theme class handle\n");
        return E_HANDLE;
    }

    refcount = InterlockedDecrement(&tc->refcount);
    /* Some buggy apps may double free HTHEME handles */
    if (refcount >= 0)
        MSSTYLES_CloseThemeFile(tc->tf);
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_FindProperty
 *
 * Locate a property in a class. Part and state IDs will be used as a
 * preference, but may be ignored in the attempt to locate the property.
 * Will scan the entire chain of overrides for this class.
 */
PTHEME_PROPERTY MSSTYLES_FindProperty(PTHEME_CLASS tc, int iPartId, int iStateId, int iPropertyPrimitive, int iPropertyId)
{
    PTHEME_CLASS next = tc;
    PTHEME_PARTSTATE ps;
    PTHEME_PROPERTY tp;

    TRACE("(%p, %d, %d, %d)\n", tc, iPartId, iStateId, iPropertyId);
     /* Try and find an exact match on part & state */
    while(next && (ps = MSSTYLES_FindPartState(next, iPartId, iStateId, &next))) {
        if((tp = MSSTYLES_PSFindProperty(ps, iPropertyPrimitive, iPropertyId))) {
            return tp;
        }
    }
    /* If that fails, and we didn't already try it, search for just part */
    if(iStateId != 0)
        iStateId = 0;
    /* As a last ditch attempt..go for just class */
    else if(iPartId != 0)
        iPartId = 0;
    else
        return NULL;

    if((tp = MSSTYLES_FindProperty(tc, iPartId, iStateId, iPropertyPrimitive, iPropertyId)))
        return tp;
    return NULL;
}

/* Prepare a bitmap to be used for alpha blending */
static BOOL prepare_alpha (HBITMAP bmp, BOOL* hasAlpha)
{
    DIBSECTION dib;
    int n;
    BYTE* p;

    *hasAlpha = FALSE;

    if (!bmp || GetObjectW( bmp, sizeof(dib), &dib ) != sizeof(dib))
        return FALSE;

    if (dib.dsBm.bmBitsPixel != 32 || dib.dsBmih.biCompression != BI_RGB)
        /* nothing to do */
        return TRUE;

    /* If all alpha values are 0xff, don't use alpha blending */
    for (n = 0, p = dib.dsBm.bmBits; n < dib.dsBmih.biWidth * dib.dsBmih.biHeight; n++, p += 4)
        if ((*hasAlpha = (p[3] != 0xff)))
            break;

    if (!*hasAlpha)
        return TRUE;

    p = dib.dsBm.bmBits;
    n = dib.dsBmih.biHeight * dib.dsBmih.biWidth;
    /* AlphaBlend() wants premultiplied alpha, so do that now */
    while (n-- > 0)
    {
        int a = p[3]+1;
        p[0] = (p[0] * a) >> 8;
        p[1] = (p[1] * a) >> 8;
        p[2] = (p[2] * a) >> 8;
        p += 4;
    }

    return TRUE;
}

HBITMAP MSSTYLES_LoadBitmap (PTHEME_CLASS tc, LPCWSTR lpFilename, BOOL* hasAlpha)
{
    WCHAR szFile[MAX_PATH];
    LPWSTR tmp;
    PTHEME_IMAGE img;
    lstrcpynW(szFile, lpFilename, ARRAY_SIZE(szFile));
    tmp = szFile;
    do {
        if(*tmp == '\\') *tmp = '_';
        if(*tmp == '/') *tmp = '_';
        if(*tmp == '.') *tmp = '_';
    } while(*tmp++);

    /* Try to locate in list of loaded images */
    img = tc->tf->images;
    while (img)
    {
        if (lstrcmpiW (szFile, img->name) == 0)
        {
            TRACE ("found %p %s: %p\n", img, debugstr_w (img->name), img->image);
            *hasAlpha = img->hasAlpha;
            return img->image;
        }
        img = img->next;
    }
    /* Not found? Load from resources */
    img = heap_alloc(sizeof(*img));
    img->image = LoadImageW(tc->hTheme, szFile, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
    prepare_alpha (img->image, hasAlpha);
    img->hasAlpha = *hasAlpha;
    /* ...and stow away for later reuse. */
    lstrcpyW (img->name, szFile);
    img->next = tc->tf->images;
    tc->tf->images = img;
    TRACE ("new %p %s: %p\n", img, debugstr_w (img->name), img->image);
    return img->image;
}

static BOOL MSSTYLES_GetNextLong(LPCWSTR lpStringStart, LPCWSTR lpStringEnd, LPCWSTR *lpValEnd, LONG *value)
{
    LPCWSTR cur = lpStringStart;
    LONG total = 0;
    BOOL gotNeg = FALSE;

    while(cur < lpStringEnd && (*cur < '0' || *cur > '9' || *cur == '-')) cur++;
    if(cur >= lpStringEnd) {
        return FALSE;
    }
    if(*cur == '-') {
        cur++;
        gotNeg = TRUE;
    }
    while(cur < lpStringEnd && (*cur >= '0' && *cur <= '9')) {
        total = total * 10 + (*cur - '0');
        cur++;
    }
    if(gotNeg) total = -total;
    *value = total;
    if(lpValEnd) *lpValEnd = cur;
    return TRUE;
}

static BOOL MSSTYLES_GetNextInteger(LPCWSTR lpStringStart, LPCWSTR lpStringEnd, LPCWSTR *lpValEnd, int *value)
{
    return MSSTYLES_GetNextLong(lpStringStart, lpStringEnd, lpValEnd, (LONG *)value);
}

static inline BOOL isSpace(WCHAR c)
{
    return c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v';
}

static BOOL MSSTYLES_GetNextToken(LPCWSTR lpStringStart, LPCWSTR lpStringEnd, LPCWSTR *lpValEnd, LPWSTR lpBuff, DWORD buffSize) {
    LPCWSTR cur = lpStringStart;
    LPCWSTR start;
    LPCWSTR end;

    while(cur < lpStringEnd && (isSpace(*cur) || *cur == ',')) cur++;
    if(cur >= lpStringEnd) {
        return FALSE;
    }
    start = cur;
    while(cur < lpStringEnd && *cur != ',') cur++;
    end = cur;
    while(isSpace(*end)) end--;

    lstrcpynW(lpBuff, start, min(buffSize, end-start+1));

    if(lpValEnd) *lpValEnd = cur;
    return TRUE;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyBool
 *
 * Retrieve a color value for a property 
 */
HRESULT MSSTYLES_GetPropertyBool(PTHEME_PROPERTY tp, BOOL *pfVal)
{
    *pfVal = FALSE;
    if(*tp->lpValue == 't' || *tp->lpValue == 'T')
        *pfVal = TRUE;
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyColor
 *
 * Retrieve a color value for a property 
 */
HRESULT MSSTYLES_GetPropertyColor(PTHEME_PROPERTY tp, COLORREF *pColor)
{
    LPCWSTR lpEnd;
    LPCWSTR lpCur;
    int red, green, blue;

    lpCur = tp->lpValue;
    lpEnd = tp->lpValue + tp->dwValueLen;

    if(!MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &red)) {
        TRACE("Could not parse color property\n");
        return E_PROP_ID_UNSUPPORTED;
    }
    if(!MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &green)) {
        TRACE("Could not parse color property\n");
        return E_PROP_ID_UNSUPPORTED;
    }
    if(!MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &blue)) {
        TRACE("Could not parse color property\n");
        return E_PROP_ID_UNSUPPORTED;
    }
    *pColor = RGB(red,green,blue);
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyColor
 *
 * Retrieve a color value for a property 
 */
static HRESULT MSSTYLES_GetFont (LPCWSTR lpCur, LPCWSTR lpEnd,
                                 LPCWSTR *lpValEnd, LOGFONTW* pFont)
{
    int pointSize;
    WCHAR attr[32];

    if(!MSSTYLES_GetNextToken(lpCur, lpEnd, &lpCur, pFont->lfFaceName, LF_FACESIZE)) {
        TRACE("Property is there, but failed to get face name\n");
        *lpValEnd = lpCur;
        return E_PROP_ID_UNSUPPORTED;
    }
    if(!MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &pointSize)) {
        TRACE("Property is there, but failed to get point size\n");
        *lpValEnd = lpCur;
        return E_PROP_ID_UNSUPPORTED;
    }
    pFont->lfHeight = pointSize;
    pFont->lfWeight = FW_REGULAR;
    pFont->lfCharSet = DEFAULT_CHARSET;
    while(MSSTYLES_GetNextToken(lpCur, lpEnd, &lpCur, attr, ARRAY_SIZE(attr))) {
        if(!lstrcmpiW(L"bold", attr)) pFont->lfWeight = FW_BOLD;
        else if(!lstrcmpiW(L"italic", attr)) pFont->lfItalic = TRUE;
        else if(!lstrcmpiW(L"underline", attr)) pFont->lfUnderline = TRUE;
        else if(!lstrcmpiW(L"strikeout", attr)) pFont->lfStrikeOut = TRUE;
    }
    *lpValEnd = lpCur;
    return S_OK;
}

HRESULT MSSTYLES_GetPropertyFont(PTHEME_PROPERTY tp, HDC hdc, LOGFONTW *pFont)
{
    LPCWSTR lpCur = tp->lpValue;
    LPCWSTR lpEnd = tp->lpValue + tp->dwValueLen;
    HRESULT hr; 

    ZeroMemory(pFont, sizeof(LOGFONTW));
    hr = MSSTYLES_GetFont (lpCur, lpEnd, &lpCur, pFont);
    if (SUCCEEDED (hr))
        pFont->lfHeight = -MulDiv(pFont->lfHeight, GetDeviceCaps(hdc, LOGPIXELSY), 72);

    return hr;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyInt
 *
 * Retrieve an int value for a property 
 */
HRESULT MSSTYLES_GetPropertyInt(PTHEME_PROPERTY tp, int *piVal)
{
    if(!MSSTYLES_GetNextInteger(tp->lpValue, (tp->lpValue + tp->dwValueLen), NULL, piVal)) {
        TRACE("Could not parse int property\n");
        return E_PROP_ID_UNSUPPORTED;
    }
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyIntList
 *
 * Retrieve an int list value for a property 
 */
HRESULT MSSTYLES_GetPropertyIntList(PTHEME_PROPERTY tp, INTLIST *pIntList)
{
    int i;
    LPCWSTR lpCur = tp->lpValue;
    LPCWSTR lpEnd = tp->lpValue + tp->dwValueLen;

    for(i=0; i < MAX_INTLIST_COUNT; i++) {
        if(!MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &pIntList->iValues[i]))
            break;
    }
    pIntList->iValueCount = i;
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyPosition
 *
 * Retrieve a position value for a property 
 */
HRESULT MSSTYLES_GetPropertyPosition(PTHEME_PROPERTY tp, POINT *pPoint)
{
    int x,y;
    LPCWSTR lpCur = tp->lpValue;
    LPCWSTR lpEnd = tp->lpValue + tp->dwValueLen;

    if(!MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &x)) {
        TRACE("Could not parse position property\n");
        return E_PROP_ID_UNSUPPORTED;
    }
    if(!MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &y)) {
        TRACE("Could not parse position property\n");
        return E_PROP_ID_UNSUPPORTED;
    }
    pPoint->x = x;
    pPoint->y = y;
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyString
 *
 * Retrieve a string value for a property 
 */
HRESULT MSSTYLES_GetPropertyString(PTHEME_PROPERTY tp, LPWSTR pszBuff, int cchMaxBuffChars)
{
    lstrcpynW(pszBuff, tp->lpValue, min(tp->dwValueLen+1, cchMaxBuffChars));
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyRect
 *
 * Retrieve a rect value for a property 
 */
HRESULT MSSTYLES_GetPropertyRect(PTHEME_PROPERTY tp, RECT *pRect)
{
    LPCWSTR lpCur = tp->lpValue;
    LPCWSTR lpEnd = tp->lpValue + tp->dwValueLen;

    MSSTYLES_GetNextLong(lpCur, lpEnd, &lpCur, &pRect->left);
    MSSTYLES_GetNextLong(lpCur, lpEnd, &lpCur, &pRect->top);
    MSSTYLES_GetNextLong(lpCur, lpEnd, &lpCur, &pRect->right);
    if(!MSSTYLES_GetNextLong(lpCur, lpEnd, &lpCur, &pRect->bottom)) {
        TRACE("Could not parse rect property\n");
        return E_PROP_ID_UNSUPPORTED;
    }
    return S_OK;
}

/***********************************************************************
 *      MSSTYLES_GetPropertyMargins
 *
 * Retrieve a margins value for a property 
 */
HRESULT MSSTYLES_GetPropertyMargins(PTHEME_PROPERTY tp, RECT *prc, MARGINS *pMargins)
{
    LPCWSTR lpCur = tp->lpValue;
    LPCWSTR lpEnd = tp->lpValue + tp->dwValueLen;

    MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &pMargins->cxLeftWidth);
    MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &pMargins->cxRightWidth);
    MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &pMargins->cyTopHeight);
    if(!MSSTYLES_GetNextInteger(lpCur, lpEnd, &lpCur, &pMargins->cyBottomHeight)) {
        TRACE("Could not parse margins property\n");
        return E_PROP_ID_UNSUPPORTED;
    }
    return S_OK;
}
