/*
 * Copyright 2024 RÃ©mi Bernon for CodeWeavers
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
 */

#ifndef __WINE_MESA_CXX_VECTOR
#define __WINE_MESA_CXX_VECTOR

#include <cstddef>
#include <cstdlib>

#include <type_traits>
#include <new>

namespace std
{

template <typename T>
struct vector
{
    size_t _capacity;
    size_t _size;
    T *_data;

    vector() : _capacity(0), _size(0), _data(nullptr) {}
    ~vector()
    {
        for (size_t i = 0; i < _size; i++) _data[i].~T();
        free(_data);
    }

    vector(vector const& other) : vector() { *this = other; }
    vector(vector&& other) : vector() { *this = std::move(other); }

    vector& operator=(vector const& other)
    {
        _capacity = other._capacity;
        _size = other._size;
        _data = (T *)malloc(_capacity * sizeof(T));
        for (size_t i = 0; i < _size; i++) new (_data + i) T(other._data[i]);
        return *this;
    }

    vector& operator=(vector&& other)
    {
        swap(_capacity, other._capacity);
        swap(_size, other._size);
        swap(_data, other._data);
        return *this;
    }

    T *data() { return _data; }
    size_t size() const { return _size; }
    bool empty() const { return _size == 0; }
    T& operator[](size_t index) { return _data[index]; }

    T& back() { return _data[_size - 1]; }
    T const& back() const { return _data[_size - 1]; }

    void reserve(size_t capacity)
    {
        if (capacity > _capacity)
        {
            T *tmp = _data;

            _capacity = capacity;
            _data = (T *)malloc(_capacity * sizeof(T));

            for (size_t i = 0; i < _size; i++)
            {
                new (_data + i) T(tmp[i]);
                tmp[i].~T();
            }

            free(tmp);
        }
    }

    void resize(size_t size)
    {
        if (size > _capacity) reserve(size > _capacity * 3 / 2 ? size : _capacity * 3 / 2);
        while (_size > size) _data[--_size].~T();
        while (_size < size) new (_data + _size++) T();
    }

    void pop_back() { _data[--_size].~T(); }
    void push_back(T const& value)
    {
        if (_size == _capacity) reserve(_capacity ? _capacity * 3 / 2 : 16);
        new (_data + _size++) T(value);
    }

    template<typename U>
    struct _iterator
    {
        U *_ptr;

        U& operator*() { return *_ptr; }
        U& operator[](size_t index) const { return _ptr[index]; }
        U *operator->() { return _ptr; }

        _iterator& operator++() { _ptr++; return *this; }
        bool operator!=(_iterator const& other) { return this->_ptr != other._ptr; }
    };

    using iterator = _iterator<T>;
    using const_iterator = _iterator<const T>;

    const_iterator begin() const { return const_iterator{this->_data}; }
    const_iterator end() const { return const_iterator{this->_data + _size}; }

    iterator begin() { return iterator{this->_data}; }
    iterator end() { return iterator{this->_data + _size}; }
};

} /* namespace std */

#endif /* __WINE_MESA_CXX_VECTOR */
